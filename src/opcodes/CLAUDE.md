# CLAUDE.md - Opcodes Module AI Context

## MISSION CRITICAL: EVM Specification Compliance

The opcodes module defines the fundamental EVM instruction set. **ANY deviation from the Ethereum Yellow Paper specification can result in consensus failures and loss of funds.** Every opcode must behave exactly as specified in the official documentation.

## Critical Implementation Details

### Core Files and Responsibilities

**File: `opcode.zig`**
- Defines canonical EVM opcodes (0x00-0xFF)
- MUST match Ethereum Yellow Paper specification exactly
- Enum values MUST correspond to actual opcode bytecode values
- Complete instruction set coverage required

**File: `opcode_data.zig`**
- Static opcode metadata for all 256 possible opcodes
- Gas costs, stack inputs/outputs, validation rules
- Drives jump table dispatch and bytecode validation
- Performance-critical: cache-friendly data layout

**File: `opcode_synthetic.zig`**
- Fusion opcodes for performance optimization
- Generated by Planner during bytecode analysis
- MUST preserve EVM semantics exactly
- Uses undefined opcode space (0xA5-0xDF) safely

## Opcode Categories - ZERO TOLERANCE FOR ERRORS

### Arithmetic Operations (0x00-0x0F)
**Critical Properties**:
- Overflow behavior: ALL arithmetic wraps (no exceptions)
- Division by zero: Returns 0 (never crashes)
- Modulo by zero: Returns 0 (never crashes)
- Signed operations use two's complement

**Gas Costs**:
- Simple ops (ADD, SUB): 3 gas
- Complex ops (MUL, DIV): 5 gas
- Modular ops (ADDMOD, MULMOD): 8 gas
- EXP: Dynamic based on exponent size

### Comparison & Logic (0x10-0x1F)
**Critical Properties**:
- All comparisons return 0 (false) or 1 (true)
- Bitwise operations on full 256-bit words
- Shift operations: out-of-range shifts return 0
- BYTE operation: out-of-range index returns 0

### Cryptographic Operations (0x20-0x2F)
**Critical Properties**:
- KECCAK256: MUST use Keccak-256, NOT SHA-3
- Memory expansion costs apply
- Hash of empty input: specific known value

### Environmental Information (0x30-0x3F)
**DANGER ZONES**:
- Context-sensitive: values depend on execution context
- BALANCE: expensive operation (2600+ gas)
- External code access: can fail with invalid addresses
- Return data: size limits and memory expansion

### Block Information (0x40-0x4F)
**Critical Properties**:
- Block hash: only available for last 256 blocks
- Timestamp: block timestamp, not current time
- Block number: current block being executed
- Gas limit: current block gas limit

### Stack Operations (0x50-0x5F, 0x80-0x8F, 0x90-0x9F)
**CRITICAL STACK INVARIANTS**:
- Stack size: exactly 1024 elements maximum
- Underflow: attempting to pop from empty stack fails
- Overflow: pushing to full stack fails
- PUSH operations: immediate values in bytecode
- DUP operations: valid indices 1-16 only
- SWAP operations: valid indices 1-16 only

### Memory Operations (0x51-0x53)
**Memory Safety Requirements**:
- Memory expansion: quadratic gas cost formula
- Word alignment: MSTORE/MLOAD operate on 32-byte words
- MSTORE8: single byte operations
- Memory grows in 32-byte words only

### Storage Operations (0x54-0x55)
**CRITICAL GAS IMPLICATIONS**:
- Cold storage access: 2100 gas first time
- Warm storage access: 100 gas subsequent times
- Storage modification gas (EIP-2929/EIP-2200)
- Refund mechanisms for storage cleanup

### Control Flow (0x56-0x5B)
**Jump Validation CRITICAL**:
- JUMPDEST: only valid jump targets
- JUMP/JUMPI: must validate destination before jumping
- Invalid jump: immediately fails execution
- PC tracking: program counter management

### Log Operations (0xA0-0xA4)
**Event Logging Requirements**:
- Topic count: 0-4 topics allowed
- Memory expansion costs
- Event data: arbitrary length memory region
- Log data ordering: preserve exact order

### System Operations (0xF0-0xFF)
**EXTREME CAUTION REQUIRED**:
- CREATE/CREATE2: contract deployment
- CALL operations: external contract interaction
- DELEGATECALL: execution context preservation
- SELFDESTRUCT: contract destruction (deprecated)

## Synthetic Opcodes - Performance Optimizations

### Fusion Patterns
**Common Fusions**:
- PUSH + arithmetic operation
- PUSH + memory operation
- Multiple PUSH operations
- ISZERO + conditional jump

**Safety Requirements**:
- MUST preserve exact EVM semantics
- Stack effects identical to separate opcodes
- Gas costs identical to separate opcodes
- No observable behavioral differences

### Static Jump Optimization
- Pre-computed jump destinations
- Eliminates binary search in dispatch
- CRITICAL: validate destinations during analysis

## Gas Cost Validation

### Static Costs (Compile-Time Verified)
- Base opcode costs defined in `opcode_data.zig`
- MUST match EIP specifications exactly
- Update costs with hardfork changes

### Dynamic Costs (Runtime Calculated)
- Memory expansion costs
- Storage access costs (cold/warm)
- Call operation costs
- EXP exponent-based costs

## Debugging Strategies

### Opcode Implementation Issues
1. **Differential Testing**: Compare with revm/geth for identical inputs
2. **EVM Test Vectors**: Validate against official Ethereum tests
3. **Stack Trace Analysis**: Monitor stack depth and contents
4. **Gas Consumption Tracking**: Verify gas calculations

### Performance Regression
1. **Opcode Dispatch Profiling**: Measure jump table performance
2. **Cache Analysis**: Monitor instruction cache efficiency
3. **Fusion Effectiveness**: Track synthetic opcode usage
4. **Memory Allocation**: Monitor allocator pressure

### Consensus Failures
1. **Immediate Halt**: Stop execution on any consensus mismatch
2. **Reference Implementation**: Compare against multiple EVMs
3. **Specification Review**: Re-examine Yellow Paper requirements
4. **Test Case Expansion**: Add failing case to test suite

## Performance Considerations

### Hot Path Optimization
1. **Jump Table**: O(1) opcode dispatch
2. **Cache Layout**: Opcode data fits in cache lines
3. **Stack Operations**: Minimize bounds checking overhead
4. **Fusion Opportunities**: Identify common patterns

### Memory Management
- Minimize allocations in opcode handlers
- Reuse buffers for temporary calculations
- Stack-allocate small, fixed-size data
- Arena allocation for batch operations

## Error Handling Patterns

### Execution Failures (Revert Transaction)
- Stack underflow/overflow
- Invalid jump destination
- Out of gas
- Invalid opcode

### Runtime Errors (Return Error)
- Memory allocation failure
- Invalid input parameters
- System-level failures

## Security Considerations

### Consensus Security
- Exact specification compliance
- Deterministic execution order
- No undefined behavior
- Consistent gas accounting

### DoS Prevention
- Gas limits enforce resource bounds
- Stack size limits prevent overflow
- Memory expansion costs prevent abuse
- Call depth limits (1024 maximum)

## Integration Requirements

### Dependencies
- `primitives` module for constants and types
- Stack module for stack operations
- Memory module for memory access
- Storage module for state access

### Used By
- EVM execution engine (instruction dispatch)
- Bytecode analyzer (static analysis)
- Gas calculation system
- Tracer system (debugging/monitoring)

## Testing Requirements

### Unit Tests MUST Cover
- All 256 possible opcode values
- Edge cases (zero values, maximum values)
- Stack boundary conditions
- Gas cost calculations
- Error conditions and recovery

### Integration Tests
- Complete instruction sequences
- Real transaction execution
- Cross-opcode interactions
- State modification sequences

### Differential Tests
- Compare with revm for all opcodes
- Official Ethereum test suite
- Synthetic test case generation

## Emergency Procedures

### Critical Opcode Bug
1. **Immediate Assessment**: Determine fund safety impact
2. **Consensus Check**: Verify other implementations
3. **Specification Review**: Confirm Yellow Paper compliance
4. **Fix Implementation**: Minimal, targeted correction
5. **Comprehensive Testing**: Full test suite validation

### Performance Regression
1. **Profile Analysis**: Identify performance bottleneck
2. **Benchmark Comparison**: Compare with baseline
3. **Optimization Implementation**: Maintain correctness
4. **Validation**: Ensure no behavioral changes

Remember: **The EVM specification is sacred law.** Any deviation, no matter how small or seemingly harmless, can lead to consensus failures and loss of funds. When in doubt, always choose specification compliance over performance.