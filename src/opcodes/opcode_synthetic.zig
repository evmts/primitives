/// Synthetic opcodes for bytecode optimization and fusion
/// 
/// Defines fused opcodes that combine common patterns for better performance:
/// - PUSH_ADD_INLINE: PUSH small_value + ADD operation combined
/// - PUSH_MUL_INLINE: PUSH small_value + MUL operation combined  
/// - PUSH_JUMP_INLINE: PUSH jump_target + JUMP operation combined
/// 
/// These synthetic opcodes are generated by the Planner during bytecode analysis
/// to reduce instruction stream length and improve cache utilization.
/// They maintain EVM semantics while providing performance optimizations.
const std = @import("std");
const Opcode = @import("opcode.zig").Opcode;

/// Synthetic opcodes for fused operations.
/// These values are chosen to avoid conflicts with standard EVM opcodes.
/// Using 0xA5-0xBF range which is undefined in the EVM specification.
/// The compile-time check below ensures no conflicts exist.
pub const OpcodeSynthetic = enum(u8) {
    PUSH_ADD_INLINE = 0xA5,
    PUSH_ADD_POINTER = 0xA6,
    PUSH_MUL_INLINE = 0xA7,
    PUSH_MUL_POINTER = 0xA8,
    PUSH_DIV_INLINE = 0xA9,
    PUSH_DIV_POINTER = 0xAA,
    PUSH_JUMP_INLINE = 0xAB,
    PUSH_JUMP_POINTER = 0xAC,
    PUSH_JUMPI_INLINE = 0xAD,
    PUSH_JUMPI_POINTER = 0xAE,
    PUSH_SUB_INLINE = 0xAF,
    PUSH_SUB_POINTER = 0xB0,
    // New: PUSH+MLOAD and PUSH+MSTORE fusions (immediate offset)
    PUSH_MLOAD_INLINE = 0xB1,
    PUSH_MLOAD_POINTER = 0xB2,
    PUSH_MSTORE_INLINE = 0xB3,
    PUSH_MSTORE_POINTER = 0xB4,
    // New: bitwise fusions and MSTORE8
    PUSH_AND_INLINE = 0xB5,
    PUSH_AND_POINTER = 0xB6,
    PUSH_OR_INLINE = 0xB7,
    PUSH_OR_POINTER = 0xB8,
    PUSH_XOR_INLINE = 0xB9,
    PUSH_XOR_POINTER = 0xBA,
    PUSH_MSTORE8_INLINE = 0xBB,
    PUSH_MSTORE8_POINTER = 0xBC,
    // Static jump optimizations - jump directly to known dispatch locations
    JUMP_TO_STATIC_LOCATION = 0xBD,   // Direct jump without binary search
    JUMPI_TO_STATIC_LOCATION = 0xBE,  // Conditional jump without binary search
    // Advanced fusion patterns (3+ opcodes)
    MULTI_PUSH_2 = 0xBF,          // Two consecutive PUSH operations
    MULTI_PUSH_3 = 0xC0,          // Three consecutive PUSH operations
    MULTI_POP_2 = 0xC1,           // Two consecutive POP operations
    MULTI_POP_3 = 0xC2,           // Three consecutive POP operations
    ISZERO_JUMPI = 0xC3,          // ISZERO + PUSH + JUMPI pattern
    DUP2_MSTORE_PUSH = 0xC4,      // DUP2 + MSTORE + PUSH pattern
};

// Compile-time check to ensure synthetic opcodes don't overlap with normal opcodes
comptime {
    @setEvalBranchQuota(10000);
    for (@typeInfo(OpcodeSynthetic).@"enum".fields) |syn_field| {
        // Try to convert the synthetic opcode value to a regular Opcode
        if (std.meta.intToEnum(Opcode, syn_field.value) catch null) |conflicting_opcode| {
            @compileError(std.fmt.comptimePrint(
                "Synthetic opcode {s} (0x{X}) conflicts with normal opcode {s}",
                .{ syn_field.name, syn_field.value, @tagName(conflicting_opcode) }
            ));
        } 
    }
}

test "OpcodeSynthetic values are unique and non-conflicting" {
    const opcodes = [_]u8{
        @intFromEnum(OpcodeSynthetic.PUSH_ADD_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_ADD_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_MUL_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_MUL_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_DIV_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_DIV_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_JUMP_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_JUMP_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_JUMPI_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_JUMPI_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_SUB_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_SUB_POINTER),
    };
    for (opcodes, 0..) |op1, i| {
        for (opcodes[i+1..]) |op2| {
            try std.testing.expect(op1 != op2);
        }
    }
    try std.testing.expectEqual(@as(u8, 0xA5), @intFromEnum(OpcodeSynthetic.PUSH_ADD_INLINE));
    try std.testing.expectEqual(@as(u8, 0xA6), @intFromEnum(OpcodeSynthetic.PUSH_ADD_POINTER));
    try std.testing.expectEqual(@as(u8, 0xA7), @intFromEnum(OpcodeSynthetic.PUSH_MUL_INLINE));
    try std.testing.expectEqual(@as(u8, 0xA8), @intFromEnum(OpcodeSynthetic.PUSH_MUL_POINTER));
    try std.testing.expectEqual(@as(u8, 0xA9), @intFromEnum(OpcodeSynthetic.PUSH_DIV_INLINE));
    try std.testing.expectEqual(@as(u8, 0xAA), @intFromEnum(OpcodeSynthetic.PUSH_DIV_POINTER));
    try std.testing.expectEqual(@as(u8, 0xAB), @intFromEnum(OpcodeSynthetic.PUSH_JUMP_INLINE));
    try std.testing.expectEqual(@as(u8, 0xAC), @intFromEnum(OpcodeSynthetic.PUSH_JUMP_POINTER));
    try std.testing.expectEqual(@as(u8, 0xAD), @intFromEnum(OpcodeSynthetic.PUSH_JUMPI_INLINE));
    try std.testing.expectEqual(@as(u8, 0xAE), @intFromEnum(OpcodeSynthetic.PUSH_JUMPI_POINTER));
    try std.testing.expectEqual(@as(u8, 0xAF), @intFromEnum(OpcodeSynthetic.PUSH_SUB_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB0), @intFromEnum(OpcodeSynthetic.PUSH_SUB_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB1), @intFromEnum(OpcodeSynthetic.PUSH_MLOAD_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB2), @intFromEnum(OpcodeSynthetic.PUSH_MLOAD_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB3), @intFromEnum(OpcodeSynthetic.PUSH_MSTORE_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB4), @intFromEnum(OpcodeSynthetic.PUSH_MSTORE_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB5), @intFromEnum(OpcodeSynthetic.PUSH_AND_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB6), @intFromEnum(OpcodeSynthetic.PUSH_AND_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB7), @intFromEnum(OpcodeSynthetic.PUSH_OR_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB8), @intFromEnum(OpcodeSynthetic.PUSH_OR_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB9), @intFromEnum(OpcodeSynthetic.PUSH_XOR_INLINE));
    try std.testing.expectEqual(@as(u8, 0xBA), @intFromEnum(OpcodeSynthetic.PUSH_XOR_POINTER));
    try std.testing.expectEqual(@as(u8, 0xBB), @intFromEnum(OpcodeSynthetic.PUSH_MSTORE8_INLINE));
    try std.testing.expectEqual(@as(u8, 0xBC), @intFromEnum(OpcodeSynthetic.PUSH_MSTORE8_POINTER));
}
