/// Synthetic opcodes for bytecode optimization and fusion
/// 
/// Defines fused opcodes that combine common patterns for better performance:
/// - PUSH_ADD_INLINE: PUSH small_value + ADD operation combined
/// - PUSH_MUL_INLINE: PUSH small_value + MUL operation combined  
/// 
/// These synthetic opcodes are generated by the Planner during bytecode analysis
/// to reduce instruction stream length and improve cache utilization.
/// They maintain EVM semantics while providing performance optimizations.
const std = @import("std");
const Opcode = @import("opcode.zig").Opcode;

/// Synthetic opcodes for fused operations.
/// These values are chosen to avoid conflicts with standard EVM opcodes.
/// Using 0xA5-0xBF range which is undefined in the EVM specification.
/// The compile-time check below ensures no conflicts exist.
pub const OpcodeSynthetic = enum(u8) {
    PUSH_ADD_INLINE = 0xA5,
    PUSH_ADD_POINTER = 0xA6,
    PUSH_MUL_INLINE = 0xA7,
    PUSH_MUL_POINTER = 0xA8,
    PUSH_DIV_INLINE = 0xA9,
    PUSH_DIV_POINTER = 0xAA,
    // 0xAB-0xAE removed - deprecated jump handlers (use static jumps instead)
    PUSH_SUB_INLINE = 0xAF,
    PUSH_SUB_POINTER = 0xB0,
    // New: PUSH+MLOAD and PUSH+MSTORE fusions (immediate offset)
    PUSH_MLOAD_INLINE = 0xB1,
    PUSH_MLOAD_POINTER = 0xB2,
    PUSH_MSTORE_INLINE = 0xB3,
    PUSH_MSTORE_POINTER = 0xB4,
    // New: bitwise fusions and MSTORE8
    PUSH_AND_INLINE = 0xB5,
    PUSH_AND_POINTER = 0xB6,
    PUSH_OR_INLINE = 0xB7,
    PUSH_OR_POINTER = 0xB8,
    PUSH_XOR_INLINE = 0xB9,
    PUSH_XOR_POINTER = 0xBA,
    PUSH_MSTORE8_INLINE = 0xBB,
    PUSH_MSTORE8_POINTER = 0xBC,
    // Static jump optimizations - jump directly to known dispatch locations
    JUMP_TO_STATIC_LOCATION = 0xBD,   // Direct jump without binary search
    JUMPI_TO_STATIC_LOCATION = 0xBE,  // Conditional jump without binary search
    // Advanced fusion patterns (3+ opcodes)
    MULTI_PUSH_2 = 0xBF,          // Two consecutive PUSH operations
    MULTI_PUSH_3 = 0xC0,          // Three consecutive PUSH operations
    MULTI_POP_2 = 0xC1,           // Two consecutive POP operations
    MULTI_POP_3 = 0xC2,           // Three consecutive POP operations
    ISZERO_JUMPI = 0xC3,          // ISZERO + PUSH + JUMPI pattern
    DUP2_MSTORE_PUSH = 0xC4,      // DUP2 + MSTORE + PUSH pattern
    
    // New high-impact fusions based on pattern analysis
    DUP3_ADD_MSTORE = 0xC5,       // DUP3 + ADD + MSTORE (60 occurrences)
    SWAP1_DUP2_ADD = 0xC6,        // SWAP1 + DUP2 + ADD (134+ occurrences)
    PUSH_DUP3_ADD = 0xC7,         // PUSH + DUP3 + ADD (58 occurrences)
    FUNCTION_DISPATCH = 0xC8,     // PUSH4 + EQ + PUSH + JUMPI (function selector)
    CALLVALUE_CHECK = 0xC9,        // CALLVALUE + DUP1 + ISZERO (payable check)
    PUSH0_REVERT = 0xCA,           // PUSH0 + PUSH0 + REVERT (error pattern)
    PUSH_ADD_DUP1 = 0xCB,          // PUSH + ADD + DUP1 (common in loops)
    MLOAD_SWAP1_DUP2 = 0xCC,       // MLOAD + SWAP1 + DUP2 (memory pattern)
    
    /// Describe the fusion operation for tracing/debugging
    pub fn describe(self: OpcodeSynthetic) []const u8 {
        return switch (self) {
            .PUSH_ADD_INLINE, .PUSH_ADD_POINTER => "PUSH+ADD fusion",
            .PUSH_SUB_INLINE, .PUSH_SUB_POINTER => "PUSH+SUB fusion",
            .PUSH_MUL_INLINE, .PUSH_MUL_POINTER => "PUSH+MUL fusion",
            .PUSH_DIV_INLINE, .PUSH_DIV_POINTER => "PUSH+DIV fusion",
            .PUSH_AND_INLINE, .PUSH_AND_POINTER => "PUSH+AND fusion",
            .PUSH_OR_INLINE, .PUSH_OR_POINTER => "PUSH+OR fusion",
            .PUSH_XOR_INLINE, .PUSH_XOR_POINTER => "PUSH+XOR fusion",
            .PUSH_MSTORE_INLINE, .PUSH_MSTORE_POINTER => "PUSH+MSTORE fusion",
            .PUSH_MSTORE8_INLINE, .PUSH_MSTORE8_POINTER => "PUSH+MSTORE8 fusion",
            .PUSH_MLOAD_INLINE, .PUSH_MLOAD_POINTER => "PUSH+MLOAD fusion",
            .JUMP_TO_STATIC_LOCATION => "Static JUMP optimization",
            .JUMPI_TO_STATIC_LOCATION => "Static JUMPI optimization",
            .MULTI_PUSH_2 => "Double PUSH fusion",
            .MULTI_PUSH_3 => "Triple PUSH fusion",
            .MULTI_POP_2 => "Double POP fusion",
            .MULTI_POP_3 => "Triple POP fusion",
            .ISZERO_JUMPI => "ISZERO+JUMPI pattern",
            .DUP2_MSTORE_PUSH => "DUP2+MSTORE+PUSH pattern",
            .DUP3_ADD_MSTORE => "DUP3+ADD+MSTORE pattern",
            .SWAP1_DUP2_ADD => "SWAP1+DUP2+ADD pattern",
            .PUSH_DUP3_ADD => "PUSH+DUP3+ADD pattern",
            .FUNCTION_DISPATCH => "Function selector dispatch (PUSH4+EQ+PUSH+JUMPI)",
            .CALLVALUE_CHECK => "Payable check (CALLVALUE+DUP1+ISZERO)",
            .PUSH0_REVERT => "Error pattern (PUSH0+PUSH0+REVERT)",
            .PUSH_ADD_DUP1 => "PUSH+ADD+DUP1 pattern",
            .MLOAD_SWAP1_DUP2 => "MLOAD+SWAP1+DUP2 pattern",
        };
    }
};

// Compile-time check to ensure synthetic opcodes don't overlap with normal opcodes
comptime {
    @setEvalBranchQuota(20000);
    for (@typeInfo(OpcodeSynthetic).@"enum".fields) |syn_field| {
        // Try to convert the synthetic opcode value to a regular Opcode
        if (std.meta.intToEnum(Opcode, syn_field.value) catch null) |conflicting_opcode| {
            @compileError(std.fmt.comptimePrint(
                "Synthetic opcode {s} (0x{X}) conflicts with normal opcode {s}",
                .{ syn_field.name, syn_field.value, @tagName(conflicting_opcode) }
            ));
        } 
    }
}

test "OpcodeSynthetic values are unique and non-conflicting" {
    const opcodes = [_]u8{
        @intFromEnum(OpcodeSynthetic.PUSH_ADD_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_ADD_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_MUL_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_MUL_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_DIV_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_DIV_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_SUB_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_SUB_POINTER),
    };
    for (opcodes, 0..) |op1, i| {
        for (opcodes[i+1..]) |op2| {
            try std.testing.expect(op1 != op2);
        }
    }
    try std.testing.expectEqual(@as(u8, 0xA5), @intFromEnum(OpcodeSynthetic.PUSH_ADD_INLINE));
    try std.testing.expectEqual(@as(u8, 0xA6), @intFromEnum(OpcodeSynthetic.PUSH_ADD_POINTER));
    try std.testing.expectEqual(@as(u8, 0xA7), @intFromEnum(OpcodeSynthetic.PUSH_MUL_INLINE));
    try std.testing.expectEqual(@as(u8, 0xA8), @intFromEnum(OpcodeSynthetic.PUSH_MUL_POINTER));
    try std.testing.expectEqual(@as(u8, 0xA9), @intFromEnum(OpcodeSynthetic.PUSH_DIV_INLINE));
    try std.testing.expectEqual(@as(u8, 0xAA), @intFromEnum(OpcodeSynthetic.PUSH_DIV_POINTER));
    try std.testing.expectEqual(@as(u8, 0xAF), @intFromEnum(OpcodeSynthetic.PUSH_SUB_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB0), @intFromEnum(OpcodeSynthetic.PUSH_SUB_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB1), @intFromEnum(OpcodeSynthetic.PUSH_MLOAD_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB2), @intFromEnum(OpcodeSynthetic.PUSH_MLOAD_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB3), @intFromEnum(OpcodeSynthetic.PUSH_MSTORE_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB4), @intFromEnum(OpcodeSynthetic.PUSH_MSTORE_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB5), @intFromEnum(OpcodeSynthetic.PUSH_AND_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB6), @intFromEnum(OpcodeSynthetic.PUSH_AND_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB7), @intFromEnum(OpcodeSynthetic.PUSH_OR_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB8), @intFromEnum(OpcodeSynthetic.PUSH_OR_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB9), @intFromEnum(OpcodeSynthetic.PUSH_XOR_INLINE));
    try std.testing.expectEqual(@as(u8, 0xBA), @intFromEnum(OpcodeSynthetic.PUSH_XOR_POINTER));
    try std.testing.expectEqual(@as(u8, 0xBB), @intFromEnum(OpcodeSynthetic.PUSH_MSTORE8_INLINE));
    try std.testing.expectEqual(@as(u8, 0xBC), @intFromEnum(OpcodeSynthetic.PUSH_MSTORE8_POINTER));
}
