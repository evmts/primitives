---
title: Primitives Library Documentation
description: Comprehensive Ethereum primitives and cryptographic operations library in Zig
template: splash
hero:
  tagline: Production-ready implementations of core Ethereum functionality
  image:
    file: ../../assets/houston.webp
  actions:
    - text: View Primitives
      link: /primitives/hardfork/
      icon: right-arrow
      variant: primary
    - text: View Crypto
      link: /crypto/crypto.zig/
      icon: seti:lock
    - text: View Precompiles
      link: /precompiles/
      icon: rocket
---

import { Card, CardGrid } from '@astrojs/starlight/components';

## ⚠️ AI-Generated Documentation

**WARNING:** This documentation was automatically generated by AI and has not been manually verified.
Please cross-reference with the actual source code for accuracy.

---

## Overview

Comprehensive Ethereum primitives and cryptographic operations library written in Zig. Provides production-ready implementations of core Ethereum functionality without an EVM execution engine.

<CardGrid stagger>
  <Card title="Primitives" icon="puzzle">
    Core Ethereum types: addresses, transactions, RLP, ABI, bytecode, opcodes, and protocol management.
  </Card>

  <Card title="Crypto" icon="seti:lock">
    Cryptographic operations: Keccak-256, secp256k1, BN254, BLS12-381, KZG commitments, and hash functions.
  </Card>

  <Card title="Precompiles" icon="rocket">
    All Ethereum precompiled contracts from 0x01 (ECRecover) to 0x13 (BLS12-381 map_fp2_to_g2).
  </Card>
</CardGrid>

## Quick Start

### Building

```bash
# Build the library
zig build

# Run all tests
zig build test

# Run with optimization
zig build -Doptimize=ReleaseFast
```

### Basic Usage

```zig
const primitives = @import("primitives");
const crypto = @import("crypto");

// Create an address from hex
const addr = try primitives.Address.fromHex("0x742d35Cc6641C91B6E...");

// Hash data with Keccak256
var hash: [32]u8 = undefined;
crypto.Crypto.keccak256(data, &hash);

// Encode with RLP
const encoded = try primitives.Rlp.encode(allocator, data);
defer allocator.free(encoded);
```

## Design Principles

1. **Type Safety** - Strong typing prevents common bugs
2. **Memory Efficiency** - Minimal allocations with clear ownership
3. **Standard Compliance** - Exact Ethereum specification adherence
4. **Performance** - Optimized critical paths
5. **Zero Tolerance** - No placeholder implementations, no error swallowing

## Security Considerations

This is mission-critical cryptographic infrastructure. Key security requirements:

- **Constant-time operations** - All cryptographic operations must be timing-attack resistant
- **Input validation** - Never trust external input
- **Memory safety** - Proper allocation/deallocation patterns
- **Side-channel resistance** - No timing, power, or cache leaks
