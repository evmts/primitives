---
title: Sign-In with Ethereum (EIP-4361)
description: Implementation of Sign-In with Ethereum (SIWE) protocol for decentralized authentication using EIP-4361 standard message format.
---

> **⚠️ WARNING: AI-Generated Documentation**
>
> This documentation was automatically generated by AI and has not been manually verified.
> Please cross-reference with the actual source code for accuracy.

## Module Purpose and Overview

The `siwe` module implements Sign-In with Ethereum (SIWE), standardized as EIP-4361. SIWE provides a secure, decentralized authentication protocol that allows users to prove ownership of an Ethereum address by signing a standardized message with their private key.

This module is critical for:
- **Web3 Authentication**: Enabling "Sign-In with Ethereum" as an alternative to traditional OAuth flows
- **Session Management**: Creating cryptographically verifiable login sessions
- **Authorization**: Proving account ownership without revealing private keys
- **Off-Chain Signatures**: Using Ethereum signatures for authentication without on-chain transactions
- **Standard Compliance**: Following the EIP-4361 message format specification

The implementation provides message formatting, parsing, validation, and signature verification with full support for all optional fields defined in the specification.

## Complete API Reference

### Types

#### `SiweError`
```zig
pub const SiweError = error{
    /// Domain field is empty (required)
    EmptyDomain,
    /// URI field is empty (required)
    EmptyUri,
    /// Version is not "1" (only version supported)
    InvalidVersion,
    /// Nonce field is empty (required)
    EmptyNonce,
    /// Issued At timestamp format is invalid
    InvalidIssuedAt,
    /// Expiration Time timestamp format is invalid
    InvalidExpirationTime,
    /// Not Before timestamp format is invalid
    InvalidNotBefore,
    /// Message format does not conform to EIP-4361
    InvalidFormat,
    /// Memory allocation failed
    OutOfMemory,
};
```

Error types specific to SIWE message validation and parsing.

#### `SiweMessage`
```zig
pub const SiweMessage = struct {
    /// RFC 4501 dns authority requesting the signing (required)
    domain: []const u8,
    /// Ethereum address performing the signing (required)
    address: Address,
    /// Human-readable ASCII assertion the user agrees to (optional)
    statement: ?[]const u8,
    /// RFC 3986 URI referring to the resource being signed (required)
    uri: []const u8,
    /// Current version of the message (must be "1")
    version: []const u8,
    /// EIP-155 Chain ID to which the session is bound (required)
    chain_id: u64,
    /// Randomized token to prevent replay attacks (required, min 8 chars)
    nonce: []const u8,
    /// ISO 8601 datetime when signature was generated (required)
    issued_at: []const u8,
    /// ISO 8601 datetime when signature expires (optional)
    expiration_time: ?[]const u8,
    /// ISO 8601 datetime before which signature is invalid (optional)
    not_before: ?[]const u8,
    /// System-specific identifier for the session (optional)
    request_id: ?[]const u8,
    /// List of information or references the user wishes to have resolved (optional)
    resources: ?[]const []const u8,

    /// Format the message according to EIP-4361 specification
    pub fn format(self: *const SiweMessage, allocator: Allocator) ![]u8;

    /// Validate required fields and formats
    pub fn validate(self: *const SiweMessage) !void;
};
```

The main SIWE message structure conforming to EIP-4361.

**Required Fields**: `domain`, `address`, `uri`, `version`, `chain_id`, `nonce`, `issued_at`

**Optional Fields**: `statement`, `expiration_time`, `not_before`, `request_id`, `resources`

### Functions

#### `verifySiweMessage`
```zig
pub fn verifySiweMessage(
    allocator: Allocator,
    message: *const SiweMessage,
    signature: crypto.Signature,
) !bool
```

Verifies a SIWE message signature and returns true if the signature is valid.

**Process**:
1. Validates message structure and required fields
2. Formats message according to EIP-4361
3. Hashes the formatted message with EIP-191 prefix
4. Recovers public key from signature
5. Derives address from public key
6. Compares recovered address with message address

**Parameters**:
- `allocator` - Memory allocator for temporary allocations
- `message` - The SIWE message to verify
- `signature` - The cryptographic signature to verify

**Returns**: `true` if signature is valid, `false` otherwise

**Errors**: `SiweError.*`, `OutOfMemory`, crypto recovery errors

#### `parseSiweMessage`
```zig
pub fn parseSiweMessage(allocator: Allocator, text: []const u8) !SiweMessage
```

Parses a formatted SIWE message string into a `SiweMessage` structure.

**Format** (EIP-4361):
```
${domain} wants you to sign in with your Ethereum account:
${address}

${statement}

URI: ${uri}
Version: ${version}
Chain ID: ${chain_id}
Nonce: ${nonce}
Issued At: ${issued_at}
Expiration Time: ${expiration_time}
Not Before: ${not_before}
Request ID: ${request_id}
Resources:
- ${resource_1}
- ${resource_2}
```

**Parameters**:
- `allocator` - Memory allocator for parsed fields
- `text` - The formatted SIWE message string

**Returns**: Parsed `SiweMessage` structure

**Errors**: `SiweError.InvalidFormat`, `OutOfMemory`

### Internal Functions

#### `isValidTimestamp`
```zig
fn isValidTimestamp(timestamp: []const u8) bool
```

Validates ISO 8601 timestamp format (YYYY-MM-DDTHH:MM:SSZ).

**Note**: This is a simplified validation checking format structure, not semantic correctness.

## Example Code Snippets

### Creating and Formatting a SIWE Message

```zig
const std = @import("std");
const siwe = @import("siwe.zig");
const address = @import("address.zig");

pub fn createSiweMessage(allocator: std.mem.Allocator) !siwe.SiweMessage {
    const user_address = try address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb7");

    return siwe.SiweMessage{
        .domain = "example.com",
        .address = user_address,
        .statement = "Sign in to Example App",
        .uri = "https://example.com/login",
        .version = "1",
        .chain_id = 1, // Ethereum Mainnet
        .nonce = "32891756",
        .issued_at = "2025-10-21T12:00:00Z",
        .expiration_time = "2025-10-21T13:00:00Z", // 1 hour expiry
        .not_before = null,
        .request_id = null,
        .resources = null,
    };
}

pub fn formatMessage(allocator: std.mem.Allocator, message: *const siwe.SiweMessage) ![]u8 {
    const formatted = try message.format(allocator);
    // Caller must free: allocator.free(formatted);
    return formatted;
}
```

### Complete Sign-In Flow

```zig
const std = @import("std");
const siwe = @import("siwe.zig");
const address = @import("address.zig");
const crypto = @import("crypto").Crypto;

pub fn signInWithEthereum(
    allocator: std.mem.Allocator,
    user_address: address.Address,
    signature_hex: []const u8,
) !bool {
    // 1. Create SIWE message
    const message = siwe.SiweMessage{
        .domain = "myapp.com",
        .address = user_address,
        .statement = "Sign in to MyApp",
        .uri = "https://myapp.com/login",
        .version = "1",
        .chain_id = 1,
        .nonce = try generateNonce(allocator),
        .issued_at = try getCurrentTimestamp(allocator),
        .expiration_time = try getExpiryTimestamp(allocator, 3600), // 1 hour
        .not_before = null,
        .request_id = null,
        .resources = null,
    };
    defer allocator.free(message.nonce);
    defer allocator.free(message.issued_at);
    defer allocator.free(message.expiration_time.?);

    // 2. Parse signature
    const signature = try parseSignature(signature_hex);

    // 3. Verify signature
    const is_valid = try siwe.verifySiweMessage(allocator, &message, signature);

    if (is_valid) {
        // 4. Create session
        try createUserSession(user_address, message.nonce);
    }

    return is_valid;
}

fn generateNonce(allocator: std.mem.Allocator) ![]u8 {
    // Generate cryptographically secure random nonce (min 8 chars recommended)
    var random_bytes: [16]u8 = undefined;
    std.crypto.random.bytes(&random_bytes);
    return std.fmt.allocPrint(allocator, "{x}", .{std.fmt.fmtSliceHexLower(&random_bytes)});
}

fn getCurrentTimestamp(allocator: std.mem.Allocator) ![]u8 {
    const timestamp = std.time.timestamp();
    return formatIso8601(allocator, timestamp);
}

fn getExpiryTimestamp(allocator: std.mem.Allocator, seconds: i64) ![]u8 {
    const timestamp = std.time.timestamp() + seconds;
    return formatIso8601(allocator, timestamp);
}

fn formatIso8601(allocator: std.mem.Allocator, timestamp: i64) ![]u8 {
    // Convert Unix timestamp to ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)
    // Implementation omitted for brevity
    return std.fmt.allocPrint(allocator, "2025-10-21T12:00:00Z", .{});
}
```

### Parsing a SIWE Message

```zig
const siwe = @import("siwe.zig");

pub fn parseReceivedMessage(allocator: std.mem.Allocator, text: []const u8) !siwe.SiweMessage {
    const message = try siwe.parseSiweMessage(allocator, text);

    // Validate message
    try message.validate();

    // Check expiration (application logic)
    if (message.expiration_time) |exp| {
        if (isExpired(exp)) {
            return error.MessageExpired;
        }
    }

    // Check not_before (application logic)
    if (message.not_before) |nb| {
        if (!isAfter(nb)) {
            return error.MessageNotYetValid;
        }
    }

    return message;
}
```

### Validating SIWE Message Fields

```zig
const siwe = @import("siwe.zig");

test "SIWE message validation" {
    const allocator = std.testing.allocator;

    // Valid message
    {
        const valid = siwe.SiweMessage{
            .domain = "example.com",
            .address = try address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb7"),
            .statement = null,
            .uri = "https://example.com/login",
            .version = "1",
            .chain_id = 1,
            .nonce = "abcd1234",
            .issued_at = "2025-10-21T12:00:00Z",
            .expiration_time = null,
            .not_before = null,
            .request_id = null,
            .resources = null,
        };

        try valid.validate(); // Should succeed
    }

    // Invalid version
    {
        const invalid = siwe.SiweMessage{
            .domain = "example.com",
            .address = try address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb7"),
            .statement = null,
            .uri = "https://example.com/login",
            .version = "2", // Invalid!
            .chain_id = 1,
            .nonce = "abcd1234",
            .issued_at = "2025-10-21T12:00:00Z",
            .expiration_time = null,
            .not_before = null,
            .request_id = null,
            .resources = null,
        };

        try std.testing.expectError(siwe.SiweError.InvalidVersion, invalid.validate());
    }
}
```

## Implementation Details

### EIP-4361 Message Format

The formatted message follows a strict structure:
1. **Header**: `${domain} wants you to sign in with your Ethereum account:`
2. **Address**: Checksum address on its own line
3. **Empty line**
4. **Statement**: Optional human-readable text (followed by empty line)
5. **Required fields**: URI, Version, Chain ID, Nonce, Issued At
6. **Optional fields**: Expiration Time, Not Before, Request ID
7. **Resources**: Optional list prefixed with "-"

### EIP-191 Signing

SIWE messages are signed using EIP-191 personal_sign format:
```
"\x19Ethereum Signed Message:\n" + len(message) + message
```

This prevents signed messages from being valid Ethereum transactions.

### Timestamp Validation

The module validates ISO 8601 timestamps with simplified rules:
- Format: `YYYY-MM-DDTHH:MM:SSZ`
- Must end with 'Z' (UTC timezone)
- Minimum 20 characters
- Checks for '-', ':', 'T' in correct positions

**Note**: This validates format only, not semantic correctness (e.g., doesn't check if February 30th is valid).

### Signature Verification Process

1. **Validate message structure**: Check all required fields present
2. **Format message**: Generate EIP-4361 compliant string
3. **Hash with EIP-191**: Prepend Ethereum signed message prefix
4. **Recover public key**: Use ECDSA recovery from signature
5. **Derive address**: Hash public key with Keccak256, take last 20 bytes
6. **Compare addresses**: Recovered address must match message address

### Memory Management

**Critical Memory Patterns**:
```zig
// format() allocates new string - caller must free
const formatted = try message.format(allocator);
defer allocator.free(formatted);

// parseSiweMessage() allocates field copies
const message = try siwe.parseSiweMessage(allocator, text);
// Caller must free individual fields if they own the message

// verifySiweMessage() handles internal allocations
const is_valid = try siwe.verifySiweMessage(allocator, &message, sig);
// No cleanup needed - internal allocations are cleaned up
```

### Nonce Requirements

- **Minimum 8 characters** (EIP-4361 recommendation)
- **Cryptographically random** to prevent replay attacks
- **Single-use**: Server must track and invalidate used nonces
- **Short-lived**: Typically valid for 5-10 minutes

### Chain ID Binding

The `chain_id` field binds the signature to a specific network:
- 1: Ethereum Mainnet
- 5: Goerli (deprecated)
- 11155111: Sepolia
- 137: Polygon
- 42161: Arbitrum One

This prevents cross-chain replay attacks.

## Error Types

### Validation Errors

- **`EmptyDomain`**: Domain field is required and cannot be empty
- **`EmptyUri`**: URI field is required and cannot be empty
- **`InvalidVersion`**: Only version "1" is currently supported
- **`EmptyNonce`**: Nonce field is required and cannot be empty
- **`InvalidIssuedAt`**: Issued At timestamp format is malformed
- **`InvalidExpirationTime`**: Expiration Time timestamp format is malformed
- **`InvalidNotBefore`**: Not Before timestamp format is malformed

### Parsing Errors

- **`InvalidFormat`**: Message does not conform to EIP-4361 structure

### System Errors

- **`OutOfMemory`**: Allocation failed during formatting or parsing

## Testing Considerations

### Test Coverage

The module includes comprehensive tests for:

1. **Message Formatting**: All field combinations (required + optional)
2. **Message Validation**: Each validation rule independently
3. **Message Parsing**: Valid and invalid message strings
4. **Signature Verification**: Valid signatures, invalid signatures, wrong addresses
5. **Timestamp Validation**: Valid and invalid ISO 8601 formats
6. **Optional Fields**: All combinations of optional fields
7. **Memory Safety**: Proper allocation and deallocation

### Test Patterns

```zig
test "SIWE message with all optional fields" {
    const allocator = std.testing.allocator;

    const resources = [_][]const u8{
        "https://example.com/resource1",
        "https://example.com/resource2",
    };

    const message = siwe.SiweMessage{
        .domain = "example.com",
        .address = try address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb7"),
        .statement = "I accept the Terms of Service",
        .uri = "https://example.com/login",
        .version = "1",
        .chain_id = 1,
        .nonce = "32891756",
        .issued_at = "2025-10-21T12:00:00Z",
        .expiration_time = "2025-10-21T13:00:00Z",
        .not_before = "2025-10-21T11:00:00Z",
        .request_id = "request-123",
        .resources = &resources,
    };

    // Test formatting
    const formatted = try message.format(allocator);
    defer allocator.free(formatted);

    // Test parsing round-trip
    const parsed = try siwe.parseSiweMessage(allocator, formatted);
    try std.testing.expectEqualStrings(message.domain, parsed.domain);
    try std.testing.expect(message.address.eql(parsed.address));
}
```

### Security Test Cases

1. **Replay Attack Prevention**: Verify nonce tracking prevents reuse
2. **Expiration Enforcement**: Test expired messages are rejected
3. **Wrong Signer**: Verify mismatched addresses fail verification
4. **Malformed Signatures**: Test invalid signature bytes are rejected
5. **Cross-Chain Protection**: Verify chain_id prevents replay across networks
6. **Message Tampering**: Test any modification invalidates signature

### Integration Testing

When testing full authentication flow:
- Generate real signatures using test wallets
- Test complete sign-in/sign-out cycles
- Verify session creation and invalidation
- Test concurrent sign-ins with nonce tracking
- Validate timestamp edge cases (expiry boundaries)

### Edge Cases to Test

1. **Empty Optional Fields**: `null` vs empty string vs empty array
2. **Special Characters**: Unicode in statement, special chars in domain
3. **Long Fields**: Very long statements, resource lists, nonces
4. **Boundary Timestamps**: Exactly at expiration, exactly at not_before
5. **Case Sensitivity**: Mixed case addresses, domains
6. **Whitespace**: Leading/trailing whitespace in fields

## Related Modules

- **address.zig**: Provides `Address` type and hex conversion
- **crypto/**: Signature verification and public key recovery
- **hex.zig**: Address formatting for message text
- **hash.zig**: EIP-191 message hashing

## Standards and Specifications

### EIP-4361: Sign-In with Ethereum

- **Purpose**: Off-chain authentication using Ethereum accounts
- **Specification**: https://eips.ethereum.org/EIPS/eip-4361
- **Status**: Final (standardized)

### EIP-191: Signed Data Standard

- **Purpose**: Prevent signed messages from being valid transactions
- **Format**: `\x19Ethereum Signed Message:\n${message_length}${message}`
- **Specification**: https://eips.ethereum.org/EIPS/eip-191

### RFC 3986: URI Specification

- Defines valid URI format for the `uri` field

### RFC 4501: DNS URI Scheme

- Defines valid format for the `domain` field

### ISO 8601: Date and Time Format

- Defines timestamp format (YYYY-MM-DDTHH:MM:SSZ)
- Used for `issued_at`, `expiration_time`, `not_before`

## Safety Considerations

### Cryptographic Security

**CRITICAL**:
- Always verify signatures before granting access
- Use cryptographically secure random for nonce generation
- Never trust client-provided timestamps without verification
- Implement proper nonce tracking to prevent replay attacks

### Session Security

- **Nonce Tracking**: Store used nonces with expiration
- **Time Validation**: Check `issued_at`, `expiration_time`, `not_before`
- **Chain Binding**: Verify `chain_id` matches expected network
- **Address Normalization**: Use checksummed addresses consistently

### Replay Attack Prevention

1. **Nonce**: Generate unique, random nonce per sign-in request
2. **Expiration**: Set reasonable `expiration_time` (5-10 minutes)
3. **Issued At**: Reject messages with future timestamps
4. **Server Storage**: Track used nonces until expiration

### Implementation Checklist

✅ Generate cryptographically secure random nonces (min 8 chars)
✅ Validate message structure before verification
✅ Use EIP-191 for message hashing
✅ Recover public key and verify signature
✅ Compare addresses using constant-time comparison
✅ Track used nonces in server storage
✅ Validate timestamps (issued_at, not_before, expiration_time)
✅ Bind to specific chain_id
✅ Handle memory safely (free all allocations)
✅ Log authentication attempts for security monitoring

### Common Pitfalls

1. **Not Checking Expiration**: Always validate `expiration_time` if present
2. **Reusing Nonces**: Nonces must be single-use
3. **Ignoring Chain ID**: Can lead to cross-chain replay attacks
4. **Poor Nonce Generation**: Predictable nonces enable replay attacks
5. **Trusting Client Timestamps**: Validate against server time
6. **Not Using EIP-191**: Raw message signatures can be valid transactions

---

**Source:** `/Users/williamcory/primitives/src/primitives/siwe.zig` (995 lines)
**Last Updated:** 2025-10-21
