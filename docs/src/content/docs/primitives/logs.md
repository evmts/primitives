---
title: EVM Event Logging
description: Data structures for representing EVM event logs with addresses, indexed topics, and non-indexed data payloads.
---

> **⚠️ WARNING: AI-Generated Documentation**
>
> This documentation was automatically generated by AI and has not been manually verified.
> Please cross-reference with the actual source code for accuracy.

## Module Purpose and Overview

The `logs` module provides a simple, efficient data structure for representing EVM event logs within the Frame execution context. Event logs are a critical component of Ethereum smart contracts, enabling contracts to emit structured data that can be indexed and queried by external applications.

This module implements the core `Log` structure containing:
- **Address**: The contract address that emitted the log
- **Topics**: Indexed parameters (up to 4) for efficient filtering
- **Data**: Non-indexed event data payload

The module also provides a `SENTINEL` value used for null-terminated log arrays in Frame operations, enabling efficient fixed-size buffer management.

## Complete API Reference

### Types

#### `Log`
```zig
pub const Log = struct {
    address: Address,
    topics: []const u256,
    data: []const u8,
};
```

The primary log structure representing an EVM event log entry.

**Fields:**
- `address: Address` - The 20-byte contract address that emitted the log
- `topics: []const u256` - Array of indexed topics (0-4 topics per EVM specification)
- `data: []const u8` - Non-indexed event data bytes

#### `SENTINEL`
```zig
pub const SENTINEL: Log = .{
    .address = Address.ZERO_ADDRESS,
    .topics = &[_]u256{},
    .data = &[_]u8{},
};
```

Special sentinel value used to mark the end of log arrays in Frame operations. This enables efficient null-terminated array patterns without requiring separate length tracking.

## Example Code Snippets

### Creating a Simple Log

```zig
const std = @import("std");
const Address = @import("address.zig").Address;
const Log = @import("logs.zig").Log;

pub fn createTransferLog(allocator: std.mem.Allocator, contract: Address, from: u256, to: u256, amount: u256) !Log {
    // Allocate topics array for Transfer event signature + indexed parameters
    const topics = try allocator.alloc(u256, 3);
    topics[0] = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef; // keccak256("Transfer(address,address,uint256)")
    topics[1] = from;
    topics[2] = to;

    // Encode amount as data (non-indexed)
    const data = try allocator.alloc(u8, 32);
    std.mem.writeInt(u256, data[0..32], amount, .big);

    return Log{
        .address = contract,
        .topics = topics,
        .data = data,
    };
}
```

### Creating a Log with Empty Topics

```zig
const Log = @import("logs.zig").Log;

pub fn createSimpleLog(contract_address: Address, message: []const u8) Log {
    return Log{
        .address = contract_address,
        .topics = &[_]u256{},  // No indexed parameters
        .data = message,
    };
}
```

### Using the SENTINEL Value

```zig
const Log = @import("logs.zig").Log;
const SENTINEL = @import("logs.zig").SENTINEL;

pub fn initLogBuffer() [100]Log {
    var logs: [100]Log = undefined;
    // Initialize all slots with sentinel
    for (&logs) |*log| {
        log.* = SENTINEL;
    }
    return logs;
}

pub fn isValidLog(log: *const Log) bool {
    // Check if log is sentinel (empty/uninitialized)
    return log.topics.len > 0 or log.data.len > 0;
}
```

## Implementation Details

### Memory Management

The `Log` structure itself is a simple aggregate type with no internal allocation. However, the `topics` and `data` fields are slices that reference externally managed memory. Callers are responsible for:

1. **Allocating** topic and data arrays
2. **Deallocating** these arrays when logs are no longer needed
3. **Lifetime management** ensuring slices remain valid while logs are in use

```zig
// Proper cleanup pattern
const topics = try allocator.alloc(u256, 2);
errdefer allocator.free(topics);

const data = try allocator.alloc(u8, 64);
errdefer allocator.free(data);

const log = Log{
    .address = some_address,
    .topics = topics,
    .data = data,
};

// Later cleanup
allocator.free(log.topics);
allocator.free(log.data);
```

### EVM LOG Opcodes

The EVM provides five log opcodes corresponding to different numbers of topics:
- `LOG0` (0xA0): 0 topics
- `LOG1` (0xA1): 1 topic
- `LOG2` (0xA2): 2 topics
- `LOG3` (0xA3): 3 topics
- `LOG4` (0xA4): 4 topics

The `Log` structure supports all variants through its flexible `topics` slice.

### Gas Costs

Log operations consume gas based on:
- **Base cost**: 375 gas per log operation
- **Topic cost**: 375 gas per topic
- **Data cost**: 8 gas per byte of data

Total: `375 + (375 * num_topics) + (8 * data_length)`

### Sentinel Pattern

The `SENTINEL` constant enables efficient log buffer management in the Frame:
- Zero address indicates uninitialized/empty slot
- Empty topics and data arrays minimize memory overhead
- Allows fast checking for log presence without separate counters

## Error Types

This module defines no custom error types. The `Log` structure is a plain data type with no methods that can fail. However, operations that create logs may encounter:

- `error.OutOfMemory` - When allocating topics or data arrays
- Address validation errors from the `address` module
- Memory safety errors if slices are incorrectly managed

## Testing Considerations

### Test Coverage

The module includes comprehensive unit tests covering:

1. **Log Creation**: Creating logs with various topic counts and data sizes
2. **Field Access**: Verifying address, topics, and data are correctly stored
3. **Empty Logs**: Logs with no topics or data
4. **Memory Management**: Proper allocation and deallocation patterns

### Test Patterns

```zig
test "Log creation and field access" {
    const allocator = std.testing.allocator;

    // Allocate topics
    const topics = try allocator.alloc(u256, 2);
    defer allocator.free(topics);
    topics[0] = 0x123456789abcdef;
    topics[1] = 0xfedcba9876543210;

    // Create log
    const data = "test log data";
    const zero_addr = [_]u8{0} ** 20;
    const log = Log{
        .address = zero_addr,
        .topics = topics,
        .data = data,
    };

    // Verify fields
    try std.testing.expectEqual(zero_addr, log.address);
    try std.testing.expectEqual(@as(usize, 2), log.topics.len);
    try std.testing.expectEqual(@as(u256, 0x123456789abcdef), log.topics[0]);
    try std.testing.expectEqualStrings("test log data", log.data);
}
```

### Edge Cases to Test

1. **Maximum Topics**: Logs with 4 topics (EVM maximum)
2. **Large Data**: Logs with large data payloads (gas limit considerations)
3. **Empty Logs**: Logs with zero topics and empty data
4. **Sentinel Comparison**: Distinguishing sentinel from valid empty logs
5. **Memory Safety**: Ensuring no use-after-free or double-free issues

### Integration Testing

When testing Frame execution:
- Verify logs are correctly appended during contract execution
- Test log ordering matches execution order
- Validate topic indexing for event filtering
- Ensure gas costs are correctly calculated
- Test log bloom filter generation for receipt trie

### Performance Testing

For performance-critical paths:
- Benchmark log creation overhead
- Measure memory allocation patterns
- Profile log serialization for RLP encoding
- Test sentinel-based buffer management efficiency

## Related Modules

- **address.zig**: Provides the `Address` type used for contract addresses
- **Frame**: Uses `Log` arrays for tracking emitted events during execution
- **event_log.zig**: Extended log functionality with bloom filters and receipts
- **rlp.zig**: Serialization of logs for transaction receipts
- **opcode.zig**: LOG0-LOG4 opcode implementations

## Standards and Specifications

- **Ethereum Yellow Paper**: Section 4.3.1 defines log semantics
- **EIP-658**: Receipt status encoding (affects log inclusion)
- **EIP-2718**: Typed transaction receipts (log serialization)
- **Solidity Events**: High-level event syntax compiles to LOG opcodes

## Safety Considerations

### Memory Safety
- Always use `defer` or `errdefer` when allocating log data
- Ensure slices remain valid for the lifetime of the `Log` structure
- Avoid dangling pointers when logs reference Frame-local memory

### Gas Exhaustion
- Validate gas availability before emitting logs
- Prevent denial-of-service through excessive log emission
- Enforce EVM gas limits on log operations

### Data Integrity
- Topics must be exactly 32 bytes (u256)
- Data can be arbitrary length but limited by gas
- Address must be valid 20-byte Ethereum address

---

**Source:** `/Users/williamcory/primitives/src/primitives/logs.zig` (54 lines)
**Last Updated:** 2025-10-21
