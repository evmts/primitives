---
title: Cryptographic Hash Implementations
description: Implementations of SHA256, RIPEMD160, and BLAKE2F hash functions for Ethereum precompile contracts.
---

> **⚠️ WARNING: AI-Generated Documentation**
>
> This documentation was automatically generated by AI and has not been manually verified.
> Please cross-reference with the actual source code for accuracy.

## Overview

The `hash_algorithms.zig` module provides implementations of cryptographic hash functions used in Ethereum precompile contracts and other blockchain operations. This module includes SHA256, RIPEMD160, and BLAKE2F implementations, supporting Ethereum precompiles 0x02 (SHA256), 0x03 (RIPEMD160), and 0x09 (BLAKE2F).

## Module Location

`/Users/williamcory/primitives/src/crypto/hash_algorithms.zig`

## Security Status

**MIXED AUDIT STATUS**:
- **SHA256**: Uses Zig's standard library implementation (considered secure)
- **RIPEMD160**: UNAUDITED custom implementation
- **BLAKE2F**: UNAUDITED custom implementation

## Supported Hash Algorithms

### SHA256

```zig
pub const SHA256 = struct {
    pub const OUTPUT_SIZE: usize = 32;

    pub fn hash(input: []const u8, output: []u8) void
    pub fn hash_fixed(input: []const u8) [OUTPUT_SIZE]u8
};
```

SHA256 (Secure Hash Algorithm 256-bit) produces a 256-bit (32-byte) cryptographic hash. This is used in Ethereum precompile 0x02.

#### Methods

##### hash()

```zig
pub fn hash(input: []const u8, output: []u8) void
```

Computes SHA256 hash of input data and writes to output buffer.

**Parameters:**
- `input` - Data to hash
- `output` - Output buffer (must be at least 32 bytes)

**Panics:** If output buffer is smaller than 32 bytes

**Example:**
```zig
const data = "hello world";
var output: [SHA256.OUTPUT_SIZE]u8 = undefined;
SHA256.hash(data, &output);
```

##### hash_fixed()

```zig
pub fn hash_fixed(input: []const u8) [OUTPUT_SIZE]u8
```

Computes SHA256 hash and returns as fixed-size array.

**Parameters:**
- `input` - Data to hash

**Returns:** 32-byte hash value

**Example:**
```zig
const data = "hello world";
const hash_value = SHA256.hash_fixed(data);
// hash_value = [0xb9, 0x4d, 0x27, 0xb9, ...]
```

#### Test Vectors

SHA256 hash of "hello world":
```
0xb94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
```

#### Implementation

Uses Zig's standard library `std.crypto.hash.sha2.Sha256`.

### RIPEMD160

```zig
pub const RIPEMD160 = struct {
    pub const OUTPUT_SIZE: usize = 20;

    pub fn hash(input: []const u8, output: []u8) void
    pub fn hash_fixed(input: []const u8) [OUTPUT_SIZE]u8
};
```

RIPEMD160 (RACE Integrity Primitives Evaluation Message Digest 160-bit) produces a 160-bit (20-byte) cryptographic hash. This is used in Ethereum precompile 0x03 and Bitcoin address generation.

#### Security Status

**WARNING: UNAUDITED** - Uses custom `ripemd160.zig` implementation that has NOT been security audited.

#### Methods

##### hash()

```zig
pub fn hash(input: []const u8, output: []u8) void
```

Computes RIPEMD160 hash of input data and writes to output buffer.

**Parameters:**
- `input` - Data to hash
- `output` - Output buffer (must be at least 20 bytes)

**Panics:** If output buffer is smaller than 20 bytes

**Example:**
```zig
const data = "abc";
var output: [RIPEMD160.OUTPUT_SIZE]u8 = undefined;
RIPEMD160.hash(data, &output);
```

##### hash_fixed()

```zig
pub fn hash_fixed(input: []const u8) [OUTPUT_SIZE]u8
```

Computes RIPEMD160 hash and returns as fixed-size array.

**Parameters:**
- `input` - Data to hash

**Returns:** 20-byte hash value

**Example:**
```zig
const data = "abc";
const hash_value = RIPEMD160.hash_fixed(data);
// hash_value = [0x8e, 0xb2, 0x08, 0xf7, ...]
```

#### Test Vectors

RIPEMD160 hash of "abc":
```
0x8eb208f7e05d987a9b044a8e98c6b087f15a0bfc
```

RIPEMD160 hash of empty string:
```
0x9c1185a5c5e9fc54612808977ee8f548b2258d31
```

#### Implementation

Uses custom implementation from `ripemd160.zig` module via `unaudited_hash()` function.

### BLAKE2F

```zig
pub const BLAKE2F = struct {
    pub const STATE_SIZE: usize = 8;      // 8 x 64-bit words
    pub const MESSAGE_SIZE: usize = 16;   // 16 x 64-bit words
    pub const OUTPUT_SIZE: usize = 64;    // 64 bytes

    pub fn unaudited_compress(
        h: *[STATE_SIZE]u64,
        m: *const [MESSAGE_SIZE]u64,
        t: [2]u64,
        f: bool,
        rounds: u32
    ) void

    pub fn unaudited_compress_eip152(input: []const u8, output: []u8) !void
};
```

BLAKE2F is the compression function used in BLAKE2b hashing. This is used in Ethereum precompile 0x09 (EIP-152).

#### Security Status

**WARNING: UNAUDITED** - Uses custom `blake2.zig` implementation that has NOT been security audited.

#### Methods

##### unaudited_compress()

```zig
pub fn unaudited_compress(
    h: *[STATE_SIZE]u64,
    m: *const [MESSAGE_SIZE]u64,
    t: [2]u64,
    f: bool,
    rounds: u32
) void
```

**WARNING: UNAUDITED** - Performs BLAKE2F compression function.

**Parameters:**
- `h` - State vector (8 x 64-bit words, modified in place)
- `m` - Message block (16 x 64-bit words)
- `t` - Offset counters (2 x 64-bit words)
- `f` - Final block flag
- `rounds` - Number of rounds to perform

**Example:**
```zig
var h: [8]u64 = initial_state;
const m: [16]u64 = message_block;
const t = [2]u64{ byte_count_low, byte_count_high };
BLAKE2F.unaudited_compress(&h, &m, t, true, 12);
```

##### unaudited_compress_eip152()

```zig
pub fn unaudited_compress_eip152(input: []const u8, output: []u8) !void
```

**WARNING: UNAUDITED** - Parses and compresses from EIP-152 format.

**Parameters:**
- `input` - 213-byte input in EIP-152 format
- `output` - 64-byte output buffer

**Returns:** Error if input format is invalid

**Errors:**
- `InvalidInputLength` - Input is not exactly 213 bytes
- `OutputBufferTooSmall` - Output buffer is smaller than 64 bytes
- `InvalidFinalFlag` - Final flag is not 0 or 1

**EIP-152 Input Format (213 bytes):**
```
Offset | Size | Description
-------|------|-------------
0      | 4    | rounds (big-endian u32)
4      | 64   | h (state vector, 8 x u64 little-endian)
68     | 128  | m (message block, 16 x u64 little-endian)
196    | 8    | t[0] (counter low, u64 little-endian)
204    | 8    | t[1] (counter high, u64 little-endian)
212    | 1    | f (final flag, 0 or 1)
```

**Output Format (64 bytes):**
```
8 x u64 values in little-endian (modified state vector)
```

**Example:**
```zig
const eip152_input: [213]u8 = ...; // EIP-152 formatted input
var output: [64]u8 = undefined;
try BLAKE2F.unaudited_compress_eip152(&eip152_input, &output);
```

## Usage Examples

### SHA256 Hashing

```zig
const hash_algorithms = @import("hash_algorithms");

// Hash a message
const message = "Hello, Ethereum!";
const hash = hash_algorithms.SHA256.hash_fixed(message);

// Verify against known hash
const expected: [32]u8 = ...;
if (std.mem.eql(u8, &hash, &expected)) {
    // Hash matches
}
```

### RIPEMD160 for Bitcoin-style Addresses

```zig
const hash_algorithms = @import("hash_algorithms");

// Public key hash (used in Bitcoin P2PKH addresses)
const pubkey: [33]u8 = ...; // Compressed public key
const sha256_hash = hash_algorithms.SHA256.hash_fixed(&pubkey);
const ripemd160_hash = hash_algorithms.RIPEMD160.hash_fixed(&sha256_hash);

// ripemd160_hash is the 20-byte pubkey hash
```

### BLAKE2F Compression for EIP-152 Precompile

```zig
const hash_algorithms = @import("hash_algorithms");

// EIP-152 precompile input (213 bytes)
const input: [213]u8 = build_eip152_input(rounds, h, m, t, f);
var output: [64]u8 = undefined;

try hash_algorithms.BLAKE2F.unaudited_compress_eip152(&input, &output);

// output contains the compressed state
```

## Testing

The module includes comprehensive test coverage for all hash functions:

### SHA256 Tests

```zig
test "SHA256 hash computation" {
    const test_input = "hello world";
    var output: [SHA256.OUTPUT_SIZE]u8 = undefined;
    SHA256.hash(test_input, &output);

    const expected = [_]u8{
        0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08,
        0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d, 0xab, 0xfa,
        0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee,
        0x90, 0x88, 0xf7, 0xac, 0xe2, 0xef, 0xcd, 0xe9,
    };

    try std.testing.expectEqualSlices(u8, &expected, &output);
}
```

### RIPEMD160 Tests

```zig
test "RIPEMD160 hash computation" {
    const test_input = "abc";
    const result = RIPEMD160.hash_fixed(test_input);

    const expected = [_]u8{
        0x8e, 0xb2, 0x08, 0xf7, 0xe0, 0x5d, 0x98, 0x7a,
        0x9b, 0x04, 0x4a, 0x8e, 0x98, 0xc6, 0xb0, 0x87,
        0xf1, 0x5a, 0x0b, 0xfc,
    };

    try std.testing.expectEqual(expected, result);
}
```

## Precompile Usage

These hash functions are used in Ethereum precompile contracts:

### Precompile 0x02 (SHA256)

```zig
// SHA256 precompile at address 0x02
const input: []const u8 = call_data;
const hash = SHA256.hash_fixed(input);
return hash; // 32 bytes
```

**Gas Cost:** 60 + 12 * (number of 32-byte words)

### Precompile 0x03 (RIPEMD160)

```zig
// RIPEMD160 precompile at address 0x03
const input: []const u8 = call_data;
const hash = RIPEMD160.hash_fixed(input);
// Pad to 32 bytes (left-padded with zeros)
var result: [32]u8 = [_]u8{0} ** 32;
@memcpy(result[12..32], &hash);
return result;
```

**Gas Cost:** 600 + 120 * (number of 32-byte words)

### Precompile 0x09 (BLAKE2F)

```zig
// BLAKE2F precompile at address 0x09
const input: []const u8 = call_data; // Must be 213 bytes
var output: [64]u8 = undefined;
try BLAKE2F.unaudited_compress_eip152(input, &output);
return output;
```

**Gas Cost:** rounds (from input)

## Security Considerations

### SHA256

- Uses Zig standard library implementation
- Considered cryptographically secure
- Well-audited and battle-tested
- No known vulnerabilities

### RIPEMD160

- **UNAUDITED custom implementation**
- Used in Bitcoin for address generation
- Algorithm is well-specified but implementation not audited
- Use with caution in production

### BLAKE2F

- **UNAUDITED custom implementation**
- EIP-152 specifies exact behavior
- Compression function only (not full BLAKE2b)
- Implementation should match reference exactly

## Best Practices

1. **Use SHA256 for general hashing** when possible (audited implementation)
2. **Validate all inputs** before hashing
3. **Check buffer sizes** to prevent panics
4. **Test against known vectors** when implementing
5. **Audit custom implementations** before production use
6. **Follow EIP specifications** exactly for precompile implementations
7. **Use fixed-size output** functions when possible for safety

## Related Modules

- `precompiles.zig` - Ethereum precompile contract implementations
- `hash_utils.zig` - Keccak256 and hash utilities
- `ripemd160.zig` - RIPEMD160 implementation details
- `blake2.zig` - BLAKE2F implementation details

## References

- [SHA-256 Specification (FIPS 180-4)](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf)
- [RIPEMD-160 Specification](https://homes.esat.kuleuven.be/~bosselae/ripemd160.html)
- [BLAKE2 Specification](https://www.blake2.net/blake2.pdf)
- [EIP-152: BLAKE2F Precompile](https://eips.ethereum.org/EIPS/eip-152)
- [Ethereum Yellow Paper - Precompiled Contracts](https://ethereum.github.io/yellowpaper/paper.pdf)

## Known Issues

- RIPEMD160 implementation needs security audit
- BLAKE2F implementation needs security audit
- No performance benchmarks included
- Consider adding streaming hash APIs for large inputs
