---
title: Swift SDK
description: Native Swift bindings for macOS, iOS, and Apple platforms
---

import { Callout } from 'vocs/components'

# Swift SDK

Swift bindings for the Guillotine EVM, providing a comprehensive, performant, and developer-friendly interface to the Ethereum Virtual Machine.

<Callout type="warning">
**Experimental/PoC**: This SDK is a vibecoded proof-of-concept. APIs are unstable and may change. We're looking for early users to try it and tell us what APIs you want.

- **Maturity**: Experimental proof-of-concept
- **API stability**: Unstable; breaking changes expected
- **Feedback**: [GitHub Issues](https://github.com/evmts/Guillotine/issues) or [Telegram](https://t.me/+ANThR9bHDLAwMjUx)
</Callout>

## Features

- **Complete EVM Implementation**: Full Ethereum Virtual Machine with gas accounting, state management, and precompiles
- **Swift-First Design**: Leverages Swift's type system, async/await, and error handling
- **Cross-Platform**: Supports macOS, iOS, watchOS, and tvOS
- **High Performance**: Direct C interop with the native Zig implementation
- **Memory Safe**: Automatic resource management using Swift's ARC
- **Comprehensive Testing**: Full test suite with XCTest

## Installation

### Swift Package Manager

Add to your `Package.swift`:

```swift filename="Package.swift"
dependencies: [
    .package(path: "../guillotine-swift")
]
```

Or add through Xcode:
1. File → Add Package Dependencies
2. Enter the path to the SDK directory
3. Click Add Package

## Quick Start

### Basic Example

```swift filename="main.swift" showLineNumbers
import GuillotineEVM
import GuillotinePrimitives

// Create EVM instance
let evm = try EVM()

// Execute bytecode
let bytecode = Bytes([0x60, 0x42]) // PUSH1 0x42
let result = try await evm.execute(bytecode: bytecode)

print("Execution successful: \(result.isSuccess)")
print("Gas used: \(result.gasUsed)")
```

### Working with Addresses

```swift filename="addresses.swift"
// Create from hex string
let address: Address = "0x1234567890123456789012345678901234567890"

// Create zero address
let zero = Address.zero

// Convert to/from bytes
let bytes = address.rawBytes
let fromBytes = try Address(bytes)

// Check properties
if address.isZero {
    print("Zero address")
}
```

### Working with U256

```swift filename="u256.swift"
// Create from integer
let value = U256(12345)

// Create from hex
let bigValue = try U256(hex: "0x1fffffffffffffffffffffffffffffffffffff")

// Arithmetic operations
let sum = try value.adding(U256(100))
let difference = try bigValue.subtracting(U256(1))
let product = try value.multiplying(U256(2))
let quotient = try bigValue.dividing(by: U256(2))

// Comparisons
if value < U256(10000) {
    print("Value is less than 10000")
}
```

## API Reference

### Core Types

#### Address
20-byte Ethereum address with hex string support.

```swift
public struct Address: Hashable, Sendable {
    public static let zero: Address
    public init(_ hexString: String) throws
    public init(_ bytes: [UInt8]) throws
    public var hexString: String { get }
    public var rawBytes: [UInt8] { get }
}
```

#### U256
256-bit unsigned integer with arithmetic operations.

```swift
public struct U256: Comparable, Sendable {
    public init(_ value: UInt64)
    public init(hex: String) throws
    public func adding(_ other: U256) throws -> U256
    public func subtracting(_ other: U256) throws -> U256
    public func multiplying(_ other: U256) throws -> U256
    public func dividing(by other: U256) throws -> U256
}
```

#### Bytes
Variable-length byte arrays with hex encoding.

```swift
public struct Bytes: Sendable {
    public init(_ data: [UInt8])
    public init(hex: String) throws
    public var hex: String { get }
    public var count: Int { get }
}
```

### EVM Class

Main execution engine with async/await support.

:::code-group

```swift [Initialization]
// Basic initialization
let evm = try EVM()

// With configuration
let evm = try EVM(config: EVMConfig(
    hardfork: .shanghai,
    enableTracing: true,
    maxCallDepth: 1024
))
```

```swift [State Management]
// Set account balance
let address: Address = "0x1234567890123456789012345678901234567890"
try evm.setBalance(address, balance: U256(1000))

// Deploy contract code
let contractCode = Bytes([0x60, 0x80, 0x60, 0x40, 0x52])
try evm.setCode(address, code: contractCode)

// Get account info
let balance = try evm.getBalance(address)
let nonce = try evm.getNonce(address)
let code = try evm.getCode(address)
```

```swift [Execution]
// Execute with parameters
let result = try await evm.execute(
    bytecode: contractCode,
    caller: Address.zero,
    to: address,
    value: U256(100),
    input: Bytes([0x01, 0x02, 0x03]),
    gasLimit: 1_000_000
)

// Check result
if result.isSuccess {
    print("Output: \(result.output.hex)")
    print("Gas used: \(result.gasUsed)")
    print("Logs: \(result.logs)")
}
```

:::

### ExecutionResult

Comprehensive execution results with gas usage and return data.

```swift
public struct ExecutionResult: Sendable {
    public let isSuccess: Bool
    public let gasUsed: UInt64
    public let gasLeft: UInt64
    public let output: Bytes
    public let logs: [Log]
    public let error: GuillotineError?
}
```

### Error Handling

```swift
public enum GuillotineError: Error {
    case executionFailed(String)
    case invalidBytecode
    case outOfGas
    case stackUnderflow
    case stackOverflow
    case invalidJump
    case invalidOpcode(UInt8)
    case revert(Bytes)
}
```

## Advanced Usage

### Async/Await Pattern

```swift filename="async.swift"
@MainActor
class EVMManager {
    private let evm: EVM
    
    init() throws {
        self.evm = try EVM()
    }
    
    func deployContract(_ bytecode: Bytes) async throws -> Address {
        let result = try await evm.execute(
            bytecode: bytecode,
            caller: Address.zero,
            gasLimit: 5_000_000
        )
        
        guard result.isSuccess,
              let address = result.createdAddress else {
            throw GuillotineError.executionFailed("Deployment failed")
        }
        
        return address
    }
    
    func callContract(
        _ address: Address,
        data: Bytes,
        from: Address
    ) async throws -> Bytes {
        let result = try await evm.execute(
            bytecode: Bytes([]),
            caller: from,
            to: address,
            input: data,
            gasLimit: 1_000_000
        )
        
        guard result.isSuccess else {
            throw result.error ?? GuillotineError.executionFailed("Call failed")
        }
        
        return result.output
    }
}
```

### SwiftUI Integration

```swift filename="ContentView.swift"
import SwiftUI
import GuillotineEVM

struct ContentView: View {
    @State private var evm: EVM?
    @State private var result: String = ""
    @State private var isLoading = false
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Guillotine EVM")
                .font(.largeTitle)
            
            Button("Execute Bytecode") {
                Task {
                    await executeBytecode()
                }
            }
            .disabled(isLoading)
            
            if isLoading {
                ProgressView()
            }
            
            Text(result)
                .font(.system(.body, design: .monospaced))
                .padding()
        }
        .padding()
        .onAppear {
            setupEVM()
        }
    }
    
    private func setupEVM() {
        do {
            evm = try EVM()
        } catch {
            result = "Failed to initialize EVM: \(error)"
        }
    }
    
    @MainActor
    private func executeBytecode() async {
        isLoading = true
        defer { isLoading = false }
        
        guard let evm = evm else { return }
        
        do {
            // PUSH1 42
            let bytecode = Bytes([0x60, 0x2A])
            let executionResult = try await evm.execute(bytecode: bytecode)
            
            result = """
            Success: \(executionResult.isSuccess)
            Gas Used: \(executionResult.gasUsed)
            Output: \(executionResult.output.hex)
            """
        } catch {
            result = "Execution failed: \(error)"
        }
    }
}
```

### Thread Safety

```swift filename="threading.swift"
import Foundation

actor EVMActor {
    private let evm: EVM
    
    init() throws {
        self.evm = try EVM()
    }
    
    func execute(_ bytecode: Bytes) async throws -> ExecutionResult {
        return try await evm.execute(bytecode: bytecode)
    }
    
    func setBalance(_ address: Address, _ balance: U256) throws {
        try evm.setBalance(address, balance: balance)
    }
}

// Usage
let evmActor = try EVMActor()

await withTaskGroup(of: ExecutionResult?.self) { group in
    for i in 0..<10 {
        group.addTask {
            let bytecode = Bytes([0x60, UInt8(i)])
            return try? await evmActor.execute(bytecode)
        }
    }
    
    for await result in group {
        if let result = result {
            print("Execution complete: \(result.gasUsed) gas")
        }
    }
}
```

## Platform Support

| Platform | Minimum Version | Status |
|----------|----------------|---------|
| macOS | 13.0+ | ✅ Fully Supported |
| iOS | 16.0+ | ✅ Fully Supported |
| watchOS | 9.0+ | ✅ Fully Supported |
| tvOS | 16.0+ | ✅ Fully Supported |
| visionOS | 1.0+ | 🚧 Experimental |

## Testing

### XCTest Example

```swift filename="EVMTests.swift"
import XCTest
import GuillotineEVM

final class EVMTests: XCTestCase {
    var evm: EVM!
    
    override func setUp() {
        super.setUp()
        evm = try! EVM()
    }
    
    override func tearDown() {
        evm = nil
        super.tearDown()
    }
    
    func testSimpleAddition() async throws {
        // PUSH1 5, PUSH1 10, ADD
        let bytecode = Bytes([0x60, 0x05, 0x60, 0x0A, 0x01])
        
        let result = try await evm.execute(bytecode: bytecode)
        
        XCTAssertTrue(result.isSuccess)
        XCTAssertGreaterThan(result.gasUsed, 0)
    }
    
    func testAddressCreation() throws {
        let address = try Address("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb")
        XCTAssertEqual(
            address.hexString.lowercased(),
            "0x742d35cc6634c0532925a3b844bc9e7595f0beb"
        )
    }
}
```

### Running Tests

```bash
# Command line
swift test

# Xcode
# Press Cmd+U to run all tests

# Run specific test
swift test --filter EVMTests.testSimpleAddition
```

## Performance Tips

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem', marginBottom: '2rem' }}>
  <div style={{
    padding: '1rem',
    background: 'var(--vocs-color_background2)',
    border: '1px solid var(--vocs-color_border)',
    borderRadius: '8px'
  }}>
    <h4 style={{ marginTop: 0, color: '#10B981' }}>✅ Do</h4>
    <ul style={{ margin: 0 }}>
      <li>Use actors for thread safety</li>
      <li>Leverage async/await</li>
      <li>Reuse EVM instances</li>
      <li>Profile with Instruments</li>
    </ul>
  </div>
  
  <div style={{
    padding: '1rem',
    background: 'var(--vocs-color_background2)',
    border: '1px solid var(--vocs-color_border)',
    borderRadius: '8px'
  }}>
    <h4 style={{ marginTop: 0, color: '#EF4444' }}>❌ Don't</h4>
    <ul style={{ margin: 0 }}>
      <li>Create EVMs on main thread</li>
      <li>Ignore error handling</li>
      <li>Block UI with sync calls</li>
      <li>Retain large byte arrays</li>
    </ul>
  </div>
</div>

## Troubleshooting

:::details[Module not found error]
**Solution**: Ensure the package is properly added to your project:
```swift
// In Package.swift
dependencies: [
    .package(path: "../path/to/guillotine-swift")
]
```
:::

:::details[Async function in synchronous context]
**Solution**: Use Task or async context:
```swift
Task {
    let result = try await evm.execute(bytecode: bytes)
}
```
:::

:::details[Memory issues on iOS]
**Solution**: Ensure proper cleanup and use autorelease pools:
```swift
autoreleasepool {
    // EVM operations
}
```
:::

## Next Steps

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem', marginTop: '2rem' }}>
  <a href="/sdks/typescript" style={{
    display: 'block',
    padding: '1.5rem',
    background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.05))',
    border: '1px solid rgba(59, 130, 246, 0.3)',
    borderRadius: '12px',
    textDecoration: 'none'
  }}>
    <h3 style={{ margin: '0 0 0.5rem 0' }}>📘 TypeScript SDK</h3>
    <p style={{ margin: 0, color: 'var(--vocs-color_text2)' }}>
      Cross-platform JavaScript bindings
    </p>
  </a>
  
  <a href="/sdks/c" style={{
    display: 'block',
    padding: '1.5rem',
    background: 'linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05))',
    border: '1px solid rgba(16, 185, 129, 0.3)',
    borderRadius: '12px',
    textDecoration: 'none'
  }}>
    <h3 style={{ margin: '0 0 0.5rem 0' }}>🔧 C SDK</h3>
    <p style={{ margin: 0, color: 'var(--vocs-color_text2)' }}>
      Low-level C API for maximum control
    </p>
  </a>
</div>

## Support

<Callout type="info">
  **Need help?**
  - 📖 Browse [examples](https://github.com/evmts/Guillotine/tree/main/sdks/swift/Examples)
  - 💬 Join our [Telegram community](https://t.me/+ANThR9bHDLAwMjUx)
  - 🐛 Report [issues on GitHub](https://github.com/evmts/Guillotine/issues)
</Callout>