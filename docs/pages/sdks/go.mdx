---
title: Go SDK
description: Use Guillotine EVM from Go applications
---

# Go SDK

The Guillotine Go SDK provides idiomatic Go bindings to the high-performance Guillotine EVM implementation. It offers native Go types, comprehensive error handling, and thread-safe operations.

## Installation

```bash
go get github.com/evmts/guillotine/sdks/go
```

## Quick Start

```go
package main

import (
    "fmt"
    "math/big"
    
    "github.com/evmts/guillotine/sdks/go/evm"
    "github.com/evmts/guillotine/sdks/go/primitives"
)

func main() {
    // Create a new EVM instance
    vm := evm.New()
    defer vm.Destroy()
    
    // Set up an account
    address := primitives.HexToAddress("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb0")
    vm.SetBalance(address, big.NewInt(1000000000000000000)) // 1 ETH
    
    // Deploy contract bytecode
    bytecode := []byte{0x60, 0x80, 0x60, 0x40, 0x52} // Example bytecode
    vm.SetCode(address, bytecode)
    
    // Execute a call
    result, err := vm.Call(&evm.CallParams{
        Caller:   primitives.HexToAddress("0x0000000000000000000000000000000000000001"),
        Target:   address,
        Value:    big.NewInt(0),
        Input:    []byte{},
        GasLimit: 1000000,
    })
    
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Execution successful: %v\n", result.Success)
    fmt.Printf("Gas used: %d\n", result.GasUsed)
}
```

## Core Types

### EVM Instance

The main entry point for interacting with the Guillotine EVM:

```go
type EVM struct {
    // Internal handle to the Zig EVM instance
}

// Create a new EVM instance
func New() *EVM

// Clean up resources
func (e *EVM) Destroy()
```

### Primitive Types

The SDK provides native Go types for Ethereum primitives:

```go
// 20-byte Ethereum address
type Address [20]byte

// 32-byte hash
type Hash [32]byte

// Conversion utilities
func HexToAddress(s string) Address
func HexToHash(s string) Hash
func BytesToAddress(b []byte) Address
func BytesToHash(b []byte) Hash
```

### Call Parameters

All EVM operations use a unified `CallParams` structure:

```go
type CallParams struct {
    Caller   Address     // Caller address
    Target   Address     // Target contract address
    Value    *big.Int    // ETH value to transfer
    Input    []byte      // Call data
    GasLimit uint64      // Gas limit for execution
    CallType CallType    // Type of call (CALL, DELEGATECALL, etc.)
}

type CallType int

const (
    Call         CallType = iota
    DelegateCall
    StaticCall
    Create
    Create2
)
```

## State Management

### Account Balances

```go
// Set account balance
func (e *EVM) SetBalance(address Address, balance *big.Int)

// Get account balance
func (e *EVM) GetBalance(address Address) *big.Int
```

### Contract Code

```go
// Deploy contract bytecode
func (e *EVM) SetCode(address Address, code []byte)

// Retrieve contract bytecode
func (e *EVM) GetCode(address Address) []byte
```

### Storage

```go
// Set storage value
func (e *EVM) SetStorage(address Address, key Hash, value Hash)

// Get storage value
func (e *EVM) GetStorage(address Address, key Hash) Hash
```

## Execution

### Basic Call

```go
result, err := vm.Call(&evm.CallParams{
    Caller:   caller,
    Target:   target,
    Value:    big.NewInt(1000000000000000000), // 1 ETH
    Input:    calldata,
    GasLimit: 1000000,
})

if err != nil {
    // Handle error
}

if result.Success {
    fmt.Printf("Return data: %x\n", result.Output)
}
```

### Delegate Call

```go
result, err := vm.Call(&evm.CallParams{
    Caller:   caller,
    Target:   implementation,
    Input:    calldata,
    GasLimit: 1000000,
    CallType: evm.DelegateCall,
})
```

### Static Call (Read-Only)

```go
result, err := vm.Call(&evm.CallParams{
    Caller:   caller,
    Target:   target,
    Input:    calldata,
    GasLimit: 1000000,
    CallType: evm.StaticCall,
})
```

### Contract Creation

```go
// CREATE
result, err := vm.Call(&evm.CallParams{
    Caller:   deployer,
    Value:    big.NewInt(0),
    Input:    constructorBytecode,
    GasLimit: 3000000,
    CallType: evm.Create,
})

if result.Success {
    contractAddress := result.CreatedAddress
    fmt.Printf("Contract deployed at: %s\n", contractAddress.Hex())
}

// CREATE2 (deterministic address)
result, err := vm.Call(&evm.CallParams{
    Caller:   deployer,
    Target:   primitives.BytesToAddress(salt), // Salt as address
    Input:    constructorBytecode,
    GasLimit: 3000000,
    CallType: evm.Create2,
})
```

## Error Handling

The SDK provides comprehensive error handling:

```go
result, err := vm.Call(params)
if err != nil {
    switch err {
    case evm.ErrOutOfGas:
        // Handle out of gas
    case evm.ErrInvalidOpcode:
        // Handle invalid opcode
    case evm.ErrStackUnderflow:
        // Handle stack underflow
    default:
        // Handle other errors
    }
}

// Check execution status
if !result.Success {
    fmt.Printf("Execution failed: %s\n", result.Reason)
}
```

## Advanced Features

### Gas Metering

```go
result, err := vm.Call(params)
fmt.Printf("Gas used: %d\n", result.GasUsed)
fmt.Printf("Gas refunded: %d\n", result.GasRefunded)
```

### Return Data

```go
result, err := vm.Call(params)
if result.Success {
    // Access return data
    returnData := result.Output
    
    // Decode return data (e.g., using go-ethereum/abi)
    // decoded := abi.Decode(returnData, ...)
}
```

### Logs

```go
result, err := vm.Call(params)
for _, log := range result.Logs {
    fmt.Printf("Log from %s\n", log.Address.Hex())
    fmt.Printf("Topics: %v\n", log.Topics)
    fmt.Printf("Data: %x\n", log.Data)
}
```

## Thread Safety

The Go SDK is designed to be thread-safe:

```go
var vm = evm.New()
defer vm.Destroy()

// Safe to use from multiple goroutines
go func() {
    vm.Call(&evm.CallParams{...})
}()

go func() {
    vm.SetBalance(address, balance)
}()
```

## Performance

The Go SDK uses CGO bindings to the Zig implementation for optimal performance:

- Zero-copy where possible
- Minimal allocation overhead
- Native big.Int support
- Efficient memory management

### Benchmarks

```go
func BenchmarkSimpleTransfer(b *testing.B) {
    vm := evm.New()
    defer vm.Destroy()
    
    for i := 0; i < b.N; i++ {
        vm.Call(&evm.CallParams{
            Caller:   sender,
            Target:   receiver,
            Value:    big.NewInt(1000),
            GasLimit: 21000,
        })
    }
}
```

## Testing

The SDK includes comprehensive test coverage:

```bash
# Run tests
go test ./...

# Run benchmarks
go test -bench=. ./...

# Run with race detector
go test -race ./...
```

## Complete Example

```go
package main

import (
    "encoding/hex"
    "fmt"
    "math/big"
    
    "github.com/evmts/guillotine/sdks/go/evm"
    "github.com/evmts/guillotine/sdks/go/primitives"
)

func main() {
    // Initialize EVM
    vm := evm.New()
    defer vm.Destroy()
    
    // Setup accounts
    deployer := primitives.HexToAddress("0x1000000000000000000000000000000000000001")
    user := primitives.HexToAddress("0x2000000000000000000000000000000000000002")
    
    // Fund accounts
    vm.SetBalance(deployer, big.NewInt(10000000000000000000)) // 10 ETH
    vm.SetBalance(user, big.NewInt(1000000000000000000))     // 1 ETH
    
    // Deploy ERC20 token contract
    // This would be your compiled contract bytecode
    contractBytecode, _ := hex.DecodeString("608060405234801561001057600080fd5b50...")
    
    deployResult, err := vm.Call(&evm.CallParams{
        Caller:   deployer,
        Input:    contractBytecode,
        GasLimit: 3000000,
        CallType: evm.Create,
    })
    
    if err != nil {
        panic(fmt.Sprintf("Deployment failed: %v", err))
    }
    
    if !deployResult.Success {
        panic(fmt.Sprintf("Contract deployment failed: %s", deployResult.Reason))
    }
    
    tokenAddress := deployResult.CreatedAddress
    fmt.Printf("Token deployed at: %s\n", tokenAddress.Hex())
    
    // Call transfer function
    // transfer(address to, uint256 amount)
    // Function selector: 0xa9059cbb
    transferData := make([]byte, 68)
    copy(transferData[0:4], []byte{0xa9, 0x05, 0x9c, 0xbb})
    copy(transferData[16:36], user[:])
    amount := big.NewInt(1000000000000000000) // 1 token
    copy(transferData[36:68], amount.Bytes())
    
    transferResult, err := vm.Call(&evm.CallParams{
        Caller:   deployer,
        Target:   tokenAddress,
        Input:    transferData,
        GasLimit: 100000,
    })
    
    if err != nil {
        panic(fmt.Sprintf("Transfer failed: %v", err))
    }
    
    if transferResult.Success {
        fmt.Println("Transfer successful!")
        fmt.Printf("Gas used: %d\n", transferResult.GasUsed)
    } else {
        fmt.Printf("Transfer failed: %s\n", transferResult.Reason)
    }
}
```

## Building from Source

The Go SDK requires the Guillotine shared library:

```bash
# Build the shared library
cd /path/to/guillotine
zig build shared -Doptimize=ReleaseFast

# Set library path (Linux/macOS)
export LD_LIBRARY_PATH=/path/to/guillotine/zig-out/lib:$LD_LIBRARY_PATH

# Or on macOS
export DYLD_LIBRARY_PATH=/path/to/guillotine/zig-out/lib:$DYLD_LIBRARY_PATH

# Build your Go application
go build ./...
```

## API Reference

### EVM Methods

- `New() *EVM` - Create new EVM instance
- `Destroy()` - Clean up resources
- `Call(params *CallParams) (*CallResult, error)` - Execute EVM call
- `SetBalance(address Address, balance *big.Int)` - Set account balance
- `GetBalance(address Address) *big.Int` - Get account balance
- `SetCode(address Address, code []byte)` - Set contract code
- `GetCode(address Address) []byte` - Get contract code
- `SetStorage(address Address, key Hash, value Hash)` - Set storage value
- `GetStorage(address Address, key Hash) Hash` - Get storage value

### Types

- `Address` - 20-byte Ethereum address
- `Hash` - 32-byte hash value
- `CallParams` - Parameters for EVM calls
- `CallResult` - Result of EVM execution
- `CallType` - Type of EVM call (Call, DelegateCall, StaticCall, Create, Create2)

## Troubleshooting

### Library Not Found

If you encounter library loading errors:

```bash
# Linux
ldd your_binary | grep guillotine

# macOS
otool -L your_binary | grep guillotine

# Ensure the library is in your library path
export LD_LIBRARY_PATH=/path/to/guillotine/zig-out/lib:$LD_LIBRARY_PATH
```

### CGO Issues

The SDK requires CGO:

```bash
# Enable CGO
export CGO_ENABLED=1

# Set C compiler if needed
export CC=gcc  # or clang
```

### Performance Tips

1. Reuse EVM instances when possible
2. Batch operations to reduce FFI overhead
3. Use appropriate gas limits
4. Profile with `go test -cpuprofile`

## See Also

- [Guillotine Documentation](/)
- [API Reference](#TODO)
- [Examples](/examples)
- [Other SDKs](/sdks)