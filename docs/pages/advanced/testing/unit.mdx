---
title: Unit Testing
description: Writing and running unit tests for Guillotine
---

# Unit Testing

Guillotine follows Zig's convention of embedding tests directly in source files. This keeps tests close to the code they test and ensures they're always up-to-date.

## Running Tests

### All Tests
```bash
# Run all tests with the module system
zig build test
```

### Specific Test Modules
```bash
# Test specific components
zig build test-evm
zig build test-frame
zig build test-stack
```

## Writing Tests

### Basic Test Structure

Tests are written inline with the source code:

```zig
const std = @import("std");
const testing = std.testing;

pub fn add(a: u256, b: u256) u256 {
    return a +% b;
}

test "add wraps on overflow" {
    const max = std.math.maxInt(u256);
    const result = add(max, 1);
    try testing.expectEqual(@as(u256, 0), result);
}
```

### Test Patterns

#### Testing Error Conditions
```zig
test "stack underflow returns error" {
    var stack = Stack.init();
    const result = stack.pop();
    try testing.expectError(error.StackUnderflow, result);
}
```

#### Testing with Allocators
```zig
test "memory expansion" {
    const allocator = testing.allocator;
    var memory = try Memory.init(allocator);
    defer memory.deinit();
    
    try memory.expand(1024);
    try testing.expectEqual(@as(usize, 1024), memory.len);
}
```

#### Differential Testing Against Known Values
```zig
test "keccak256 matches known hash" {
    const input = "hello world";
    const expected = [_]u8{
        0x47, 0x17, 0x32, 0x85, 0xa8, 0xd7, 0x34, 0x1e,
        0x5e, 0x97, 0x2f, 0xc6, 0x77, 0x28, 0x63, 0x84,
        0xf8, 0x02, 0xf8, 0xef, 0x42, 0xa5, 0xec, 0x5f,
        0x03, 0xff, 0xc9, 0x25, 0x14, 0x52, 0x1c, 0x16,
    };
    
    const result = keccak256(input);
    try testing.expectEqualSlices(u8, &expected, &result);
}
```

## Testing EVM Components

### Frame Tests
```zig
test "frame executes PUSH1 correctly" {
    const allocator = testing.allocator;
    var frame = try Frame.init(allocator, &[_]u8{ 0x60, 0x42 }); // PUSH1 42
    defer frame.deinit();
    
    try frame.step();
    try testing.expectEqual(@as(u256, 0x42), frame.stack.peek());
}
```

### Opcode Handler Tests
```zig
test "ADD opcode" {
    var frame = try createTestFrame(&[_]u8{ 0x60, 0x01, 0x60, 0x02, 0x01 });
    defer frame.deinit();
    
    // Execute: PUSH1 1, PUSH1 2, ADD
    while (!frame.is_stopped()) {
        try frame.step();
    }
    
    try testing.expectEqual(@as(u256, 3), frame.stack.peek());
}
```

### State Management Tests
```zig
test "journal reverts state changes" {
    var journal = Journal.init(allocator);
    defer journal.deinit();
    
    const snapshot = try journal.snapshot();
    
    // Make changes
    try journal.set_storage(address, key, value);
    try testing.expectEqual(value, journal.get_storage(address, key));
    
    // Revert
    try journal.revert(snapshot);
    try testing.expectEqual(@as(u256, 0), journal.get_storage(address, key));
}
```

## Test Utilities

### Common Test Helpers

```zig
fn createTestFrame(bytecode: []const u8) !*Frame {
    const allocator = testing.allocator;
    var frame = try allocator.create(Frame);
    frame.* = try Frame.init(allocator, bytecode);
    return frame;
}

fn expectGasUsed(frame: *Frame, expected: u64) !void {
    const used = frame.gas_limit - frame.gas_remaining;
    try testing.expectEqual(expected, used);
}
```

### Test Data Generators

```zig
fn randomAddress() Address {
    var prng = std.rand.DefaultPrng.init(0);
    var bytes: [20]u8 = undefined;
    prng.random().bytes(&bytes);
    return Address.from_bytes(bytes);
}

fn deployTestContract(evm: *Evm, bytecode: []const u8) !Address {
    const params = CallParams{ .create = .{
        .caller = Address.zero(),
        .init_code = bytecode,
        .value = 0,
        .gas = 1_000_000,
    }};
    
    const result = try evm.call(params);
    return result.created_address.?;
}
```

## Testing Best Practices

### 1. Test Naming
```zig
// Good: Descriptive test names
test "SSTORE increases gas cost for cold storage slot"
test "frame reverts on stack overflow at 1024 items"

// Bad: Vague names
test "storage test"
test "stack works"
```

### 2. Test Independence
Each test should be completely independent:
```zig
test "each test gets fresh state" {
    // Always create new instances
    var evm = try Evm.init(testing.allocator);
    defer evm.deinit();
    
    // Test in isolation
    // ...
}
```

### 3. Error Path Coverage
Always test both success and failure cases:
```zig
test "division by zero returns error" {
    var frame = try createTestFrame(&[_]u8{ 
        0x60, 0x01,  // PUSH1 1
        0x60, 0x00,  // PUSH1 0
        0x04,        // DIV
    });
    defer frame.deinit();
    
    const result = frame.execute();
    try testing.expectError(error.DivisionByZero, result);
}
```

### 4. Gas Accounting
Verify gas costs match specification:
```zig
test "SLOAD costs 2100 gas for cold slot" {
    var frame = try createTestFrame(&[_]u8{ 
        0x60, 0x00,  // PUSH1 0
        0x54,        // SLOAD
    });
    frame.gas_remaining = 10_000;
    
    try frame.step(); // PUSH1
    try frame.step(); // SLOAD
    
    try expectGasUsed(frame, 3 + 2100); // 3 for PUSH1, 2100 for cold SLOAD
}
```

## Performance Testing

### Benchmarking
```zig
test "benchmark keccak256" {
    const iterations = 10_000;
    var timer = try std.time.Timer.start();
    
    var i: usize = 0;
    while (i < iterations) : (i += 1) {
        _ = keccak256("benchmark input data");
    }
    
    const elapsed = timer.read();
    const ns_per_op = elapsed / iterations;
    std.debug.print("Keccak256: {} ns/op\n", .{ns_per_op});
}
```

### Memory Leak Detection
```zig
test "no memory leaks in frame execution" {
    const allocator = testing.allocator;
    
    var i: usize = 0;
    while (i < 1000) : (i += 1) {
        var frame = try Frame.init(allocator, &[_]u8{ 0x00 }); // STOP
        defer frame.deinit();
        try frame.execute();
    }
    
    // Test allocator will detect leaks
}
```

## Continuous Integration

Tests run automatically on CI:
- Every push to main branch
- All pull requests
- Release builds

### Local CI Simulation
```bash
# Run the same checks as CI
zig build test
zig build test -Doptimize=ReleaseSafe
zig build test -Doptimize=ReleaseFast
```

## Common Issues

### Module Import Errors
If you see "package 'primitives' not found":
```bash
# Must use build system, not direct zig test
zig build test  #  Correct
zig test src/evm.zig  # L Wrong - missing modules
```

### Test Output
Remember: Zig tests output **nothing** when passing:
```bash
$ zig build test
All tests passed.  # Only output on success
```

Use `--verbose` for more details:
```bash
zig build test --verbose
```

## Next Steps

- Learn about [Differential Testing](/advanced/testing/differential)
- Explore [Fuzzing](/advanced/testing/fuzzing)
- Read [Contributing Guidelines](/contributing/guidelines)