---
title: EVM Core
description: Deep dive into Guillotine's EVM implementation
---

# EVM Core

The EVM core is the heart of Guillotine, orchestrating all aspects of transaction execution. It's designed to be highly configurable at compile-time while maintaining zero runtime overhead.

## Configuration

The EVM is parameterized by a compile-time configuration:

```zig
pub fn Evm(comptime config: EvmConfig) type {
    return struct {
        // Configuration-specific types
        pub const Frame = @import("frame/frame.zig").Frame(config.frame_config());
        pub const Bytecode = BytecodeFactory(.{
            .max_bytecode_size = config.max_bytecode_size,
            .fusions_enabled = config.enable_fusion,
        });
        // ... more specialized types
    };
}
```

### EvmConfig Options

```zig
pub const EvmConfig = struct {
    // Hardfork and EIP configuration
    eips: Eips = Eips{ .hardfork = Hardfork.CANCUN },
    
    // Execution limits
    max_call_depth: u11 = 1024,
    max_input_size: u18 = 131072, // 128 KB
    
    // Feature toggles
    enable_precompiles: bool = true,
    enable_fusion: bool = true,
    
    // Stack configuration
    stack_size: u12 = 1024,
    WordType: type = u256,
    
    // Code size limits
    max_bytecode_size: u32 = 24576,
    max_initcode_size: u32 = 49152,
    
    // Gas limits
    block_gas_limit: u64 = 30_000_000,
    
    // Memory configuration
    memory_initial_capacity: usize = 4096,
    memory_limit: u64 = 0xFFFFFF,
    
    // Optional tracer
    TracerType: ?type = null,
};
```

## Transaction Execution Flow

### 1. Initialization

```zig
// Create configured EVM type
const MyEvm = Evm(config);

// Initialize with allocator
var evm = try MyEvm.init(allocator);
defer evm.deinit();
```

### 2. Transaction Setup

The EVM sets up the transaction context:
- Load sender and receiver accounts
- Verify balance for value transfer
- Initialize access lists (EIP-2930)
- Create execution journal for reverts

### 3. Bytecode Analysis

Before execution, bytecode is analyzed:
- Validate jump destinations
- Identify fusion opportunities
- Calculate static gas costs
- Build optimized dispatch table

### 4. Frame Execution

The Frame handles actual opcode execution:
- Manages program counter
- Dispatches to opcode handlers
- Maintains stack and memory
- Handles control flow

### 5. State Updates

After successful execution:
- Apply state changes from journal
- Update account balances
- Store modified storage slots
- Clean up self-destructed contracts

## Call Stack Management

Guillotine tracks nested calls with a call stack:

```zig
const CallStackEntry = struct {
    caller: primitives.Address,
    value: config.WordType,
    is_static: bool, // EIP-214: Track static context
};
```

### Call Types

- **CALL** - Standard contract call
- **DELEGATECALL** - Execute in caller's context
- **STATICCALL** - Read-only execution (EIP-214)
- **CREATE** - Deploy new contract
- **CREATE2** - Deterministic deployment (EIP-1014)

### Depth Limiting

Call depth is configurable and type-safe:
- Uses `u8` for depths ≤ 255
- Uses `u11` for depths ≤ 2047
- Compile-time optimization based on config

## State Management

### Journal System

The journal tracks all state changes for potential revert:

```zig
pub const Journal = struct {
    // Configurable snapshot ID type
    SnapshotIdType: type = u8,
    
    // State changes
    account_changes: ArrayList(AccountChange),
    storage_changes: ArrayList(StorageChange),
    
    // Snapshot management
    snapshots: ArrayList(Snapshot),
};
```

### Access Lists (EIP-2930)

Tracks accessed accounts and storage:
- Reduces gas costs for pre-declared access
- Improves transaction predictability
- Required for some post-Berlin operations

## Error Handling

Guillotine uses explicit error types:

```zig
pub const Error = error{
    InvalidJump,
    OutOfGas,
    StackUnderflow,
    StackOverflow,
    ContractNotFound,
    PrecompileError,
    MemoryError,
    StorageError,
    CallDepthExceeded,
    InsufficientBalance,
    ContractCollision,
    InvalidBytecode,
    StaticCallViolation,
    InvalidOpcode,
    RevertExecution,
    OutOfMemory,
    AllocationError,
};
```

### Success Cases

```zig
pub const Success = enum {
    Stop,        // Normal termination
    Return,      // Return with data
    SelfDestruct,// Contract destroyed
    Jump,        // Fusion support
};
```

## Gas Accounting

Gas is tracked at multiple levels:

1. **Static costs** - Pre-calculated during analysis
2. **Dynamic costs** - Calculated during execution
3. **Memory expansion** - Quadratic cost formula
4. **Storage operations** - SSTORE gas schedule

### Gas Optimization

- Batch static gas calculations
- Pre-compute memory expansion costs
- Cache warm/cold storage access

## Integration Points

### Database Interface

```zig
pub const Database = struct {
    get_account: fn(address: Address) ?Account,
    get_storage: fn(address: Address, key: U256) U256,
    set_storage: fn(address: Address, key: U256, value: U256) void,
    // ...
};
```

### Tracer Support

Optional execution tracing:
```zig
if (config.TracerType) |Tracer| {
    const tracer = Tracer.init();
    tracer.on_opcode(pc, opcode, gas_left);
}
```

### Precompiles

Efficient precompiled contracts:
- ECRECOVER (0x01)
- SHA256 (0x02)
- RIPEMD160 (0x03)
- IDENTITY (0x04)
- MODEXP (0x05)
- And more...

## Performance Considerations

### Memory Allocation

Uses arena allocator for transaction scope:
- Pre-allocated capacity reduces allocations
- Bulk deallocation at transaction end
- No fragmentation or GC overhead

### Opcode Dispatch

Indirect threading via tail calls:
- Better branch prediction than switch
- Minimal overhead between opcodes
- Compiler can inline hot paths

### Stack Operations

Unsafe operations after validation:
```zig
// Safe wrapper validates
pub fn add(self: *Frame) Error!void {
    if (self.stack.len < 2) return error.StackUnderflow;
    // Unsafe operation for speed
    const b = self.stack.pop_unsafe();
    const a = self.stack.peek_unsafe();
    self.stack.set_top_unsafe(a +% b);
}
```

## Next Steps

- Explore [Memory Management](/architecture/memory) strategies
- Learn about the [API Reference](/api/evm)
- Understand [Opcode Implementation](/api/opcodes)