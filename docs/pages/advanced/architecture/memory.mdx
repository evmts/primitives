---
title: Memory Management
description: Understanding Guillotine's memory allocation and management strategies
---

# Memory Management

Guillotine employs sophisticated memory management strategies to achieve high performance while maintaining safety and predictability. The system is designed to minimize allocations, prevent fragmentation, and ensure efficient cleanup.

## Arena-Based Allocation

At the core of Guillotine's memory strategy is the `GrowingArenaAllocator`, a custom allocator that provides:

- **Bulk allocation** - All memory for a transaction from a single pool
- **Zero fragmentation** - No memory holes or waste
- **Predictable cleanup** - Single deallocation at transaction end
- **Controlled growth** - Configurable expansion strategy

## GrowingArenaAllocator

### Design

```zig
pub const GrowingArenaAllocator = struct {
    arena: std.heap.ArenaAllocator,     // Underlying arena
    base_allocator: std.mem.Allocator,  // Base allocator (e.g., page allocator)
    current_capacity: usize,            // Current pre-allocated size
    initial_capacity: usize,            // Starting capacity
    growth_factor: u32,                 // Growth percentage (e.g., 150 = 50% growth)
};
```

### Initialization

```zig
// Create arena with 32KB initial capacity, 50% growth
var arena = GrowingArenaAllocator.init(
    base_allocator,
    32 * 1024,  // 32KB initial
    150         // Grow by 50% when needed
);
defer arena.deinit();

// Get allocator interface
const allocator = arena.allocator();
```

### Growth Strategy

When allocation exceeds current capacity:

1. **Calculate new size** - Apply growth factor
2. **Pre-allocate space** - Reserve additional memory
3. **Update capacity** - Track new limit
4. **Retry allocation** - Complete the request

```zig
// Example: Current capacity 32KB, need 40KB
// New capacity = 32KB * 1.5 = 48KB
// Additional allocation = 48KB - 32KB = 16KB
```

### Benefits

- **Predictable performance** - No unexpected allocation delays
- **Reduced syscalls** - Fewer trips to OS for memory
- **Cache efficiency** - Memory locality improves CPU cache usage
- **Simple cleanup** - One deallocation frees everything

## Transaction Memory Lifecycle

### 1. Transaction Start

```zig
// Initialize EVM with arena allocator
var arena = GrowingArenaAllocator.init(allocator, 32 * 1024, 150);
defer arena.deinit();

var evm = try Evm.init(arena.allocator());
defer evm.deinit();
```

### 2. During Execution

Memory is allocated for:
- **Stack frames** - Execution contexts
- **EVM memory** - Contract memory expansion
- **Journal entries** - State change tracking
- **Temporary buffers** - Intermediate calculations

```zig
// All allocations go through arena
const frame = try allocator.create(Frame);
const memory = try allocator.alloc(u8, memory_size);
const journal_entry = try allocator.create(JournalEntry);
```

### 3. Transaction Complete

```zig
// Automatic cleanup with defer
// arena.deinit() frees all memory at once
```

## EVM Memory Management

The EVM has its own memory space separate from allocation:

### Memory Expansion

EVM memory expands dynamically:

```zig
pub const Memory = struct {
    data: []u8,
    size: usize,
    allocator: Allocator,
    
    pub fn expand(self: *Memory, new_size: usize) !void {
        if (new_size <= self.size) return;
        
        // Calculate expansion cost
        const gas_cost = calculateMemoryGas(new_size);
        
        // Expand to word boundary
        const word_size = (new_size + 31) / 32 * 32;
        
        // Reallocate
        self.data = try self.allocator.realloc(self.data, word_size);
        
        // Zero new memory
        @memset(self.data[self.size..word_size], 0);
        
        self.size = word_size;
    }
};
```

### Gas Costs

Memory expansion has quadratic gas cost:

```zig
fn calculateMemoryGas(size: usize) u64 {
    const word_count = (size + 31) / 32;
    const linear_cost = word_count * 3;
    const quadratic_cost = (word_count * word_count) / 512;
    return linear_cost + quadratic_cost;
}
```

## Stack Allocation

The EVM stack uses fixed-size allocation:

```zig
pub const Stack = struct {
    data: [1024]u256,  // Fixed size, no allocation
    len: usize,
    
    // Stack operations don't allocate
    pub fn push(self: *Stack, value: u256) !void {
        if (self.len >= 1024) return error.StackOverflow;
        self.data[self.len] = value;
        self.len += 1;
    }
};
```

Benefits:
- **Zero allocations** - Stack is embedded
- **Cache friendly** - Contiguous memory
- **Predictable size** - Known at compile time

## Storage and State

### Journal Allocations

State changes are journaled for reverts:

```zig
pub const Journal = struct {
    allocator: Allocator,
    entries: ArrayList(Entry),
    snapshots: ArrayList(Snapshot),
    
    pub fn record_storage_change(
        self: *Journal,
        address: Address,
        key: U256,
        old_value: U256,
        new_value: U256
    ) !void {
        const entry = try self.allocator.create(StorageEntry);
        entry.* = .{
            .address = address,
            .key = key,
            .old_value = old_value,
            .new_value = new_value,
        };
        try self.entries.append(.{ .storage = entry });
    }
};
```

### Access List

Tracks accessed storage for gas optimization:

```zig
pub const AccessList = struct {
    allocator: Allocator,
    accounts: HashMap(Address, void),
    storage: HashMap(StorageKey, void),
    
    // Pre-allocate expected size
    pub fn init(allocator: Allocator, expected_size: usize) !AccessList {
        return .{
            .allocator = allocator,
            .accounts = try HashMap(Address, void).init(allocator, expected_size),
            .storage = try HashMap(StorageKey, void).init(allocator, expected_size * 4),
        };
    }
};
```

## Memory Safety

### Ownership Rules

1. **Arena owns all memory** - No manual free needed
2. **Clear lifetime** - Transaction scope
3. **No double-free** - Arena prevents this
4. **No use-after-free** - Scope-based cleanup

### Safety Patterns

```zig
// Good: Let arena handle cleanup
var arena = GrowingArenaAllocator.init(...);
defer arena.deinit();
const data = try arena.allocator().alloc(u8, 1024);
// No explicit free needed

// Bad: Manual memory management
const data = try allocator.alloc(u8, 1024);
defer allocator.free(data);  // Easy to forget!
```

## Performance Optimizations

### Pre-allocation

Initial capacity avoids early growth:

```zig
// Typical transaction needs ~32KB
// Pre-allocate to avoid growth overhead
var arena = GrowingArenaAllocator.init(allocator, 32 * 1024, 150);
```

### Batch Operations

Arena enables efficient batch operations:

```zig
// Create multiple objects efficiently
const frames = try allocator.alloc(Frame, max_depth);
// All allocated contiguously
```

### Memory Reuse

Between transactions, arena can retain capacity:

```zig
// Reset but keep allocated memory
_ = arena.reset(.retain_capacity);
// Next transaction reuses memory
```

## Configuration

Memory behavior is configurable:

```zig
const config = EvmConfig{
    // Initial memory for EVM operations
    .memory_initial_capacity = 4096,
    
    // Maximum memory limit
    .memory_limit = 0xFFFFFF,  // ~16MB
    
    // Stack configuration
    .stack_size = 1024,
    
    // Bytecode limits
    .max_bytecode_size = 24576,
    .max_initcode_size = 49152,
};
```

## Best Practices

1. **Use arena for transaction scope** - All transaction allocations through arena
2. **Pre-allocate appropriately** - Set initial capacity based on expected usage
3. **Configure growth factor** - Balance between memory usage and allocations
4. **Reset between transactions** - Reuse memory when possible
5. **Monitor capacity** - Track actual usage to tune initial size

## Debugging

### Memory Tracking

```zig
// Query current usage
const used = arena.queryCapacity();
log.debug("Memory used: {} bytes", .{used});

// Track growth events
if (new_capacity > old_capacity) {
    log.debug("Arena grew: {} -> {}", .{old_capacity, new_capacity});
}
```

### Safety Modes

```bash
# Build with safety checks
zig build -Doptimize=ReleaseSafe

# Full debug mode
zig build -Doptimize=Debug
```

## Next Steps

- Learn about the [EVM Core](/advanced/architecture/evm-core) implementation
- Explore the [API Reference](#TODO) for usage
- Understand [State Management](#TODO) patterns