---
title: C API
description: Using Guillotine from C and C++
---

# C API

Guillotine provides a complete C API for integration with C and C++ projects.

:::warning[Early Alpha]
The C API is in early alpha and subject to breaking changes.
Currently, you must build from source to generate C headers.
:::

## Building the C API

### Generate Headers and Library

::::steps
### Build Guillotine C API

```bash
cd Guillotine
zig build c-api
```

This generates:
- `zig-out/include/guillotine.h` - C header file
- `zig-out/lib/libguillotine.a` - Static library
- `zig-out/lib/libguillotine.so` - Shared library (Linux/macOS)
- `zig-out/lib/guillotine.dll` - Dynamic library (Windows)

### Include in Your Project

Copy the headers and library to your project:

```bash
cp zig-out/include/guillotine.h /path/to/your/project/include/
cp zig-out/lib/libguillotine.a /path/to/your/project/lib/
```
::::

## Basic Usage

### Hello EVM

```c
#include <stdio.h>
#include <stdlib.h>
#include "guillotine.h"

int main() {
    // Initialize EVM
    guillotine_evm_t* evm = guillotine_evm_create();
    if (!evm) {
        fprintf(stderr, "Failed to create EVM\n");
        return 1;
    }
    
    // Execute simple bytecode: PUSH1 42
    uint8_t bytecode[] = {0x60, 0x2A};
    
    guillotine_result_t result;
    int status = guillotine_execute(
        evm, 
        bytecode, 
        sizeof(bytecode), 
        &result
    );
    
    if (status == GUILLOTINE_SUCCESS) {
        printf("Success! Stack top: %llu\n", result.stack_top);
        printf("Gas used: %llu\n", result.gas_used);
    } else {
        printf("Execution failed: %s\n", 
               guillotine_error_string(status));
    }
    
    // Cleanup
    guillotine_evm_destroy(evm);
    return 0;
}
```

### Compilation

:::code-group

```bash [GCC/Clang]
gcc -o my_evm main.c -lguillotine -L./lib -I./include
./my_evm
```

```bash [CMake]
# CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(MyEVM)

add_executable(my_evm main.c)
target_include_directories(my_evm PRIVATE ${CMAKE_SOURCE_DIR}/include)
target_link_libraries(my_evm ${CMAKE_SOURCE_DIR}/lib/libguillotine.a)
```

```bash [Makefile]
# Makefile
CC = gcc
CFLAGS = -I./include -Wall -O2
LDFLAGS = -L./lib -lguillotine

my_evm: main.c
    $(CC) $(CFLAGS) -o $@ $< $(LDFLAGS)

clean:
    rm -f my_evm
```

:::

## API Reference

### Initialization

```c
// Create EVM with default configuration
guillotine_evm_t* guillotine_evm_create(void);

// Create EVM with custom configuration
guillotine_evm_t* guillotine_evm_create_with_config(
    const guillotine_config_t* config
);

// Destroy EVM instance
void guillotine_evm_destroy(guillotine_evm_t* evm);
```

### Configuration

```c
typedef struct {
    // Hardfork selection
    guillotine_hardfork_t hardfork;
    
    // Features
    bool enable_precompiles;
    bool enable_fusion;
    
    // Limits
    uint32_t max_call_depth;
    uint32_t max_input_size;
    uint32_t stack_size;
    uint64_t gas_limit;
    uint64_t memory_limit;
} guillotine_config_t;

// Hardfork enumeration
typedef enum {
    GUILLOTINE_HARDFORK_FRONTIER,
    GUILLOTINE_HARDFORK_HOMESTEAD,
    GUILLOTINE_HARDFORK_BYZANTIUM,
    GUILLOTINE_HARDFORK_BERLIN,
    GUILLOTINE_HARDFORK_LONDON,
    GUILLOTINE_HARDFORK_SHANGHAI,
    GUILLOTINE_HARDFORK_CANCUN,
} guillotine_hardfork_t;
```

### Execution

```c
// Execute bytecode
int guillotine_execute(
    guillotine_evm_t* evm,
    const uint8_t* bytecode,
    size_t bytecode_len,
    guillotine_result_t* result
);

// Call contract
int guillotine_call(
    guillotine_evm_t* evm,
    const guillotine_call_params_t* params,
    guillotine_result_t* result
);

// Create contract
int guillotine_create(
    guillotine_evm_t* evm,
    const guillotine_create_params_t* params,
    uint8_t* address_out  // 20 bytes
);
```

### Call Parameters

```c
typedef struct {
    uint8_t caller[20];     // Caller address
    uint8_t target[20];     // Contract address
    uint8_t value[32];      // ETH value (big-endian)
    const uint8_t* data;    // Call data
    size_t data_len;        // Data length
    uint64_t gas;           // Gas limit
    bool is_static;         // Static call flag
} guillotine_call_params_t;

typedef struct {
    uint8_t deployer[20];   // Deployer address
    uint8_t value[32];      // ETH value
    const uint8_t* init_code; // Initialization code
    size_t init_code_len;   // Code length
    uint64_t gas;           // Gas limit
    const uint8_t* salt;    // Salt for CREATE2 (optional, 32 bytes)
} guillotine_create_params_t;
```

### Results

```c
typedef struct {
    // Execution status
    guillotine_status_t status;
    
    // Return data
    uint8_t* return_data;
    size_t return_data_len;
    
    // Gas metrics
    uint64_t gas_used;
    uint64_t gas_refund;
    
    // Stack (for simple executions)
    uint8_t stack_top[32];
    
    // Revert reason (if reverted)
    char* revert_reason;
} guillotine_result_t;

// Status codes
typedef enum {
    GUILLOTINE_SUCCESS = 0,
    GUILLOTINE_REVERT = 1,
    GUILLOTINE_OUT_OF_GAS = 2,
    GUILLOTINE_INVALID_OPCODE = 3,
    GUILLOTINE_STACK_UNDERFLOW = 4,
    GUILLOTINE_INVALID_JUMP = 5,
    GUILLOTINE_ERROR = -1,
} guillotine_status_t;
```

### Transaction Context

```c
// Set transaction context
void guillotine_set_tx_context(
    guillotine_evm_t* evm,
    const guillotine_tx_context_t* ctx
);

typedef struct {
    uint8_t origin[20];     // Transaction origin
    uint64_t gas_price;     // Gas price
    uint64_t block_number;  // Block number
    uint64_t timestamp;     // Unix timestamp
    uint64_t gas_limit;     // Block gas limit
    uint64_t chain_id;      // Chain ID
    uint8_t* base_fee;      // Base fee (optional, 32 bytes)
} guillotine_tx_context_t;
```

### State Operations

```c
// Account operations
int guillotine_get_balance(
    guillotine_evm_t* evm,
    const uint8_t address[20],
    uint8_t balance_out[32]
);

int guillotine_set_balance(
    guillotine_evm_t* evm,
    const uint8_t address[20],
    const uint8_t balance[32]
);

// Storage operations
int guillotine_get_storage(
    guillotine_evm_t* evm,
    const uint8_t address[20],
    const uint8_t key[32],
    uint8_t value_out[32]
);

int guillotine_set_storage(
    guillotine_evm_t* evm,
    const uint8_t address[20],
    const uint8_t key[32],
    const uint8_t value[32]
);

// Code operations
int guillotine_get_code(
    guillotine_evm_t* evm,
    const uint8_t address[20],
    uint8_t** code_out,
    size_t* code_len
);

int guillotine_set_code(
    guillotine_evm_t* evm,
    const uint8_t address[20],
    const uint8_t* code,
    size_t code_len
);
```

### Memory Management

```c
// Free allocated memory
void guillotine_free(void* ptr);

// Free result structure
void guillotine_result_free(guillotine_result_t* result);

// Get last error message
const char* guillotine_get_last_error(guillotine_evm_t* evm);
```

## Complete Examples

### ERC-20 Transfer

```c
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "guillotine.h"

// Build ERC-20 transfer call data
void build_transfer_calldata(
    uint8_t* calldata,
    const uint8_t recipient[20],
    uint64_t amount
) {
    // transfer(address,uint256) selector: 0xa9059cbb
    calldata[0] = 0xa9;
    calldata[1] = 0x05;
    calldata[2] = 0x9c;
    calldata[3] = 0xbb;
    
    // Recipient address (padded to 32 bytes)
    memset(&calldata[4], 0, 12);
    memcpy(&calldata[16], recipient, 20);
    
    // Amount (32 bytes, big-endian)
    memset(&calldata[36], 0, 32);
    for (int i = 0; i < 8; i++) {
        calldata[67 - i] = (amount >> (i * 8)) & 0xFF;
    }
}

int main() {
    // Initialize EVM
    guillotine_config_t config = {
        .hardfork = GUILLOTINE_HARDFORK_CANCUN,
        .enable_precompiles = true,
        .enable_fusion = true,
        .gas_limit = 3000000,
    };
    
    guillotine_evm_t* evm = guillotine_evm_create_with_config(&config);
    
    // Addresses
    uint8_t sender[20] = {0x74, 0x2d, /* ... */};
    uint8_t token[20] = {0xA0, 0xb8, /* ... */};
    uint8_t recipient[20] = {0x5a, 0xAe, /* ... */};
    
    // Build transfer call data
    uint8_t calldata[68];
    build_transfer_calldata(calldata, recipient, 1000000); // 1 USDC
    
    // Set transaction context
    guillotine_tx_context_t ctx = {
        .gas_price = 20000000000ULL,
        .block_number = 18000000,
        .timestamp = 1700000000,
        .chain_id = 1,
    };
    memcpy(ctx.origin, sender, 20);
    guillotine_set_tx_context(evm, &ctx);
    
    // Execute transfer
    guillotine_call_params_t params = {
        .gas = 100000,
        .data = calldata,
        .data_len = sizeof(calldata),
        .is_static = false,
    };
    memcpy(params.caller, sender, 20);
    memcpy(params.target, token, 20);
    memset(params.value, 0, 32);
    
    guillotine_result_t result;
    int status = guillotine_call(evm, &params, &result);
    
    // Handle result
    if (status == GUILLOTINE_SUCCESS) {
        printf("✅ Transfer successful!\n");
        printf("   Gas used: %llu\n", result.gas_used);
    } else if (status == GUILLOTINE_REVERT) {
        printf("❌ Transfer reverted: %s\n", result.revert_reason);
    } else {
        printf("❌ Error: %s\n", guillotine_error_string(status));
    }
    
    // Cleanup
    guillotine_result_free(&result);
    guillotine_evm_destroy(evm);
    
    return 0;
}
```

### Contract Deployment

```c
int deploy_contract(
    guillotine_evm_t* evm,
    const uint8_t* bytecode,
    size_t bytecode_len,
    const uint8_t* constructor_args,
    size_t args_len,
    uint8_t address_out[20]
) {
    // Combine bytecode and constructor arguments
    size_t init_code_len = bytecode_len + args_len;
    uint8_t* init_code = malloc(init_code_len);
    memcpy(init_code, bytecode, bytecode_len);
    memcpy(init_code + bytecode_len, constructor_args, args_len);
    
    // Deployer address
    uint8_t deployer[20] = {/* ... */};
    
    // Create params
    guillotine_create_params_t params = {
        .init_code = init_code,
        .init_code_len = init_code_len,
        .gas = 1000000,
        .salt = NULL, // Use CREATE, not CREATE2
    };
    memcpy(params.deployer, deployer, 20);
    memset(params.value, 0, 32);
    
    // Deploy
    int status = guillotine_create(evm, &params, address_out);
    
    free(init_code);
    return status;
}
```

## Error Handling

### Error Codes

```c
const char* guillotine_error_string(int error_code) {
    switch (error_code) {
        case GUILLOTINE_SUCCESS:
            return "Success";
        case GUILLOTINE_REVERT:
            return "Execution reverted";
        case GUILLOTINE_OUT_OF_GAS:
            return "Out of gas";
        case GUILLOTINE_INVALID_OPCODE:
            return "Invalid opcode";
        case GUILLOTINE_STACK_UNDERFLOW:
            return "Stack underflow";
        case GUILLOTINE_INVALID_JUMP:
            return "Invalid jump destination";
        default:
            return "Unknown error";
    }
}
```

### Error Handling Pattern

```c
int execute_with_retry(
    guillotine_evm_t* evm,
    const uint8_t* bytecode,
    size_t len
) {
    guillotine_result_t result;
    int attempts = 0;
    
    while (attempts < 3) {
        int status = guillotine_execute(evm, bytecode, len, &result);
        
        if (status == GUILLOTINE_SUCCESS) {
            printf("Success after %d attempts\n", attempts + 1);
            guillotine_result_free(&result);
            return 0;
        }
        
        if (status == GUILLOTINE_OUT_OF_GAS && attempts < 2) {
            printf("Retrying with more gas...\n");
            // Increase gas limit for next attempt
            attempts++;
            continue;
        }
        
        fprintf(stderr, "Failed: %s\n", guillotine_error_string(status));
        guillotine_result_free(&result);
        return -1;
    }
    
    return -1;
}
```

## Memory Management

### Best Practices

1. **Always free results**:
```c
guillotine_result_t result;
guillotine_execute(evm, bytecode, len, &result);
// Use result...
guillotine_result_free(&result);
```

2. **Free allocated data**:
```c
uint8_t* code;
size_t code_len;
guillotine_get_code(evm, address, &code, &code_len);
// Use code...
guillotine_free(code);
```

3. **Destroy EVM when done**:
```c
guillotine_evm_t* evm = guillotine_evm_create();
// Use EVM...
guillotine_evm_destroy(evm);
```

## Thread Safety

:::warning[Thread Safety]
Guillotine's C API is **NOT thread-safe**. Each thread must have its own EVM instance.
:::

```c
// WRONG: Sharing EVM across threads
guillotine_evm_t* global_evm = guillotine_evm_create();

void* thread_func(void* arg) {
    // DON'T DO THIS - race condition!
    guillotine_execute(global_evm, ...);
}

// CORRECT: Each thread has own EVM
void* thread_func(void* arg) {
    guillotine_evm_t* evm = guillotine_evm_create();
    guillotine_execute(evm, ...);
    guillotine_evm_destroy(evm);
}
```

## Performance Tips

1. **Reuse EVM instances** - Creation has overhead
2. **Use static linking** - Better optimization
3. **Enable LTO** - Link-time optimization
4. **Profile your code** - Find bottlenecks

## Building for Different Platforms

### Static Library

```bash
zig build-lib -static -O ReleaseFast src/c_api.zig
```

### Dynamic Library

```bash
# Linux
zig build-lib -dynamic -O ReleaseFast src/c_api.zig -femit-bin=libguillotine.so

# macOS
zig build-lib -dynamic -O ReleaseFast src/c_api.zig -femit-bin=libguillotine.dylib

# Windows
zig build-lib -dynamic -O ReleaseFast src/c_api.zig -femit-bin=guillotine.dll
```

## Next Steps

- **[Go Bindings](/advanced/bindings/go)** - Coming soon
- **[TypeScript Bindings](/advanced/bindings/typescript)** - Coming soon
- **[Examples](https://github.com/williamcory/Guillotine/tree/main/examples/c)** - More C examples
- **[Performance Guide](/advanced/performance/optimization)** - Optimization tips