---
title: Guillotine Docs
description: Minimal, functional documentation for building, testing, and using the Zig EVM.
---

# Guillotine Docs (Alpha)

Purely functional docs. No marketing. If anything is unclear or wrong, open an issue.

## Quick Start

- Prerequisites: Zig 0.15.1+, Git
- Build: `zig build`
- Verify: `zig build && zig build test-opcodes`
- Full test suite: `zig build test` (slower)

## Core Commands

- `zig build`: Build project
- `zig build test-opcodes`: Run opcode differential tests
- `zig build test`: Run all tests
- `zig build --list-steps`: Show available steps

## Minimal Example

This example executes a STOP-only contract at a fixed address.

```zig
const std = @import("std");
const primitives = @import("primitives");
const DefaultEvm = @import("evm").DefaultEvm;
const Database = @import("storage/database.zig").Database;
const BlockInfo = @import("block/block_info.zig").DefaultBlockInfo;
const TransactionContext = @import("block/transaction_context.zig").TransactionContext;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var db = Database.init(allocator);
    defer db.deinit();

    const block = BlockInfo{
        .number = 1,
        .timestamp = 1,
        .difficulty = 0,
        .gas_limit = 30_000_000,
        .coinbase = primitives.ZERO_ADDRESS,
        .base_fee = 0,
        .prev_randao = [_]u8{0} ** 32,
    };

    const tx = TransactionContext{
        .gas_limit = 1_000_000,
        .coinbase = primitives.ZERO_ADDRESS,
        .chain_id = 1,
    };

    var evm = try DefaultEvm.init(allocator, &db, block, tx, 0, primitives.ZERO_ADDRESS, .CANCUN);
    defer evm.deinit();

    const addr: primitives.Address = .{ .bytes = [_]u8{0x12} ++ [_]u8{0} ** 19 };
    const bytecode = [_]u8{0x00}; // STOP
    const code_hash = try db.set_code(&bytecode);
    try db.set_account(addr.bytes, .{ .balance = 0, .nonce = 0, .code_hash = code_hash, .storage_root = [_]u8{0} ** 32 });

    const params = DefaultEvm.CallParams{ .call = .{
        .caller = primitives.ZERO_ADDRESS,
        .to = addr,
        .value = 0,
        .input = &.{},
        .gas = 100_000,
    } };

    const result = evm.call(params);
    if (!result.success) return error.ExecutionFailed;
}
```

## Architecture Overview

### Memory Management
- **Arena allocation**: Transaction-scoped memory with automatic cleanup
- **Database lifecycle**: Always pair `Database.init()` with `defer db.deinit()`
- **EVM frame stack**: Managed internally, requires `evm.deinit()`

### Performance Features
- **Tail-call dispatch**: Eliminates function call overhead (~25% speedup)
- **Opcode fusion**: Common patterns like PUSH+ADD become single operations
- **Unsafe operations**: `_unsafe` variants skip bounds checks after validation
- **Pre-computed jumps**: Bytecode analysis caches JUMPDEST locations

### Gas System
- Exact Yellow Paper compliance for all operations
- Memory expansion: quadratic cost `(sizeÂ² / 512) + (3 * size)`
- Storage tiers: 20000 (new), 5000 (existing), 2100 (cold), 100 (warm)
- Stack limit: 1024 items maximum

### Build Configuration

Key compile-time options:

```bash
# Performance modes
zig build -Doptimize=ReleaseFast    # Benchmarking
zig build -Doptimize=ReleaseSafe    # Alpha testing
zig build -Doptimize=ReleaseSmall   # Size-optimized

# EVM configuration
-Devm-hardfork=CANCUN              # Hardfork selection
-Devm-disable-gas=true             # Testing only (never production)
-Devm-memory-limit=16777215        # Memory limit (16MB default)
-Devm-stack-size=1024              # Stack size (EVM standard)
```

## Notes

- Alpha quality; interfaces can change
- Tests print nothing on success by design
- All allocation patterns require `defer` cleanup
- For debug logs in tests:

```zig
test {
    std.testing.log_level = .debug;
}
```

Report issues and gaps on GitHub.

