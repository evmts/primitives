---
title: Examples
description: Practical examples and code patterns for using Guillotine
---

import { Callout } from 'vocs/components'

# Examples

Learn by example with these practical code samples demonstrating common Guillotine use cases.

## 📚 Basic Examples

### Simple Addition Contract

Execute a contract that performs addition:

```zig filename="addition.zig" showLineNumbers
const std = @import("std");
const g = @import("guillotine");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Initialize components
    var db = g.Database.init(allocator);
    defer db.deinit();
    
    var block = g.BlockInfo.init();
    const tx = g.TransactionContext{ .gas_limit = 1_000_000 };
    
    const Evm = g.Evm(.{});
    var evm = try Evm.init(allocator, &db, block, tx, 0, g.Primitives.ZERO_ADDRESS, .CANCUN);
    defer evm.deinit();

    // Contract: adds two numbers from calldata
    // CALLDATALOAD(0) + CALLDATALOAD(32) 
    const code = [_]u8{
        0x60, 0x00, 0x35,  // PUSH1 0, CALLDATALOAD
        0x60, 0x20, 0x35,  // PUSH1 32, CALLDATALOAD
        0x01,              // ADD
        0x60, 0x00, 0x52,  // PUSH1 0, MSTORE
        0x60, 0x20, 0x60, 0x00, 0xF3  // RETURN 32 bytes
    };
    
    // Deploy contract
    const code_hash = try db.set_code(&code);
    const contract = g.Primitives.Address.from_u256(0x1234);
    var account = g.Account.zero();
    account.code_hash = code_hash;
    try db.set_account(contract.bytes, account);

    // Prepare calldata: 5 + 10
    var calldata: [64]u8 = [_]u8{0} ** 64;
    std.mem.writeInt(u256, calldata[0..32], 5, .big);
    std.mem.writeInt(u256, calldata[32..64], 10, .big);
    
    // Call contract
    const params = Evm.CallParams{ .call = .{
        .caller = g.Primitives.ZERO_ADDRESS,
        .to = contract,
        .value = 0,
        .input = &calldata,
        .gas = 100_000,
    } };
    
    const result = evm.call(params);
    if (result.success) {
        const sum = std.mem.readInt(u256, result.output[0..32], .big);
        std.debug.print("5 + 10 = {}\n", .{sum}); // Output: 15
    }
}
```

### ERC20-like Token Operations

Simulate basic token operations:

```zig filename="token.zig" showLineNumbers
const std = @import("std");
const g = @import("guillotine");

// Simple token contract bytecode
// Implements balanceOf(address) and transfer(address,uint256)
fn deployToken(db: *g.Database, address: g.Primitives.Address) !void {
    // Simplified ERC20 bytecode (pseudocode representation)
    const code = [_]u8{
        // Function selector dispatch
        0x60, 0x00, 0x35, 0x60, 0xE0, 0x1C,  // Get function selector
        
        // balanceOf: 0x70a08231
        0x63, 0x70, 0xa0, 0x82, 0x31, 0x14,  // PUSH4 selector
        // ... implementation returns balance from storage
        
        // transfer: 0xa9059cbb  
        0x63, 0xa9, 0x05, 0x9c, 0xbb, 0x14,  // PUSH4 selector
        // ... implementation updates balances in storage
    };
    
    const code_hash = try db.set_code(&code);
    var account = g.Account.zero();
    account.code_hash = code_hash;
    account.balance = 1_000_000; // Initial supply
    try db.set_account(address.bytes, account);
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var db = g.Database.init(allocator);
    defer db.deinit();
    
    // Deploy token contract
    const token_addr = g.Primitives.Address.from_u256(0xTOKEN);
    try deployToken(&db, token_addr);
    
    // Setup EVM
    var block = g.BlockInfo.init();
    const tx = g.TransactionContext{ .gas_limit = 1_000_000 };
    const Evm = g.Evm(.{});
    var evm = try Evm.init(allocator, &db, block, tx, 0, g.Primitives.ZERO_ADDRESS, .CANCUN);
    defer evm.deinit();
    
    // Call balanceOf(address)
    var calldata: [36]u8 = [_]u8{0} ** 36;
    // Function selector for balanceOf
    calldata[0..4].* = [_]u8{ 0x70, 0xa0, 0x82, 0x31 };
    // Address parameter
    std.mem.writeInt(u256, calldata[4..36], 0xUSER, .big);
    
    const params = Evm.CallParams{ .call = .{
        .caller = g.Primitives.ZERO_ADDRESS,
        .to = token_addr,
        .value = 0,
        .input = &calldata,
        .gas = 100_000,
    } };
    
    const result = evm.call(params);
    if (result.success) {
        const balance = std.mem.readInt(u256, result.output[0..32], .big);
        std.debug.print("Token balance: {}\n", .{balance});
    }
}
```

## 🔧 Advanced Examples

### Custom Precompile Implementation

Add a custom precompile to the EVM:

```zig filename="custom_precompile.zig" showLineNumbers
const std = @import("std");
const g = @import("guillotine");

// Custom precompile: XOR two 32-byte values
fn xor_precompile(input: []const u8, gas: u64) g.PrecompileResult {
    // Gas cost: 100 + 10 per 32-byte word
    const word_count = (input.len + 31) / 32;
    const gas_cost = 100 + word_count * 10;
    
    if (gas < gas_cost) {
        return .{ .error = error.OutOfGas };
    }
    
    if (input.len < 64) {
        return .{ .error = error.InvalidInput };
    }
    
    // XOR first two 32-byte values
    var result: [32]u8 = undefined;
    for (input[0..32], input[32..64], 0..) |a, b, i| {
        result[i] = a ^ b;
    }
    
    return .{
        .success = .{
            .output = result[0..],
            .gas_used = gas_cost,
        }
    };
}

// Configure EVM with custom precompile
const CustomConfig = g.EvmConfig{
    .custom_precompiles = &[_]g.Precompile{
        .{
            .address = g.Primitives.Address.from_u256(0x100), // Address 0x100
            .execute = xor_precompile,
        },
    },
};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var db = g.Database.init(allocator);
    defer db.deinit();
    
    var block = g.BlockInfo.init();
    const tx = g.TransactionContext{ .gas_limit = 1_000_000 };
    
    // Use custom config
    const Evm = g.Evm(CustomConfig);
    var evm = try Evm.init(allocator, &db, block, tx, 0, g.Primitives.ZERO_ADDRESS, .CANCUN);
    defer evm.deinit();
    
    // Call the custom precompile
    var input: [64]u8 = undefined;
    std.mem.writeInt(u256, input[0..32], 0xFF00FF00, .big);
    std.mem.writeInt(u256, input[32..64], 0x00FF00FF, .big);
    
    const params = Evm.CallParams{ .call = .{
        .caller = g.Primitives.ZERO_ADDRESS,
        .to = g.Primitives.Address.from_u256(0x100), // Precompile address
        .value = 0,
        .input = &input,
        .gas = 1000,
    } };
    
    const result = evm.call(params);
    if (result.success) {
        const xor_result = std.mem.readInt(u256, result.output[0..32], .big);
        std.debug.print("XOR result: 0x{X}\n", .{xor_result}); // 0xFFFFFFFF
    }
}
```

### State Journaling and Reverts

Demonstrate state rollback on revert:

```zig filename="journaling.zig" showLineNumbers
const std = @import("std");
const g = @import("guillotine");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var db = g.Database.init(allocator);
    defer db.deinit();
    
    var block = g.BlockInfo.init();
    const tx = g.TransactionContext{ .gas_limit = 1_000_000 };
    
    const Evm = g.Evm(.{});
    var evm = try Evm.init(allocator, &db, block, tx, 0, g.Primitives.ZERO_ADDRESS, .CANCUN);
    defer evm.deinit();
    
    // Contract that reverts after modifying state
    const code = [_]u8{
        // Store value 100 at slot 0
        0x60, 0x64,  // PUSH1 100
        0x60, 0x00,  // PUSH1 0
        0x55,        // SSTORE
        
        // Revert
        0x60, 0x00,  // PUSH1 0
        0x60, 0x00,  // PUSH1 0
        0xFD,        // REVERT
    };
    
    // Deploy contract
    const code_hash = try db.set_code(&code);
    const contract = g.Primitives.Address.from_u256(0x5555);
    var account = g.Account.zero();
    account.code_hash = code_hash;
    try db.set_account(contract.bytes, account);
    
    // Check storage before call
    const slot_before = try db.get_storage(contract.bytes, 0);
    std.debug.print("Storage before: {}\n", .{slot_before}); // 0
    
    // Call contract (will revert)
    const params = Evm.CallParams{ .call = .{
        .caller = g.Primitives.ZERO_ADDRESS,
        .to = contract,
        .value = 0,
        .input = &.{},
        .gas = 100_000,
    } };
    
    const result = evm.call(params);
    std.debug.print("Call success: {}\n", .{result.success}); // false
    
    // Check storage after revert - should be unchanged
    const slot_after = try db.get_storage(contract.bytes, 0);
    std.debug.print("Storage after revert: {}\n", .{slot_after}); // 0 (unchanged)
}
```

### Gas Metering Example

Track gas consumption across operations:

```zig filename="gas_metering.zig" showLineNumbers
const std = @import("std");
const g = @import("guillotine");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var db = g.Database.init(allocator);
    defer db.deinit();
    
    var block = g.BlockInfo.init();
    const tx = g.TransactionContext{ .gas_limit = 1_000_000 };
    
    const Evm = g.Evm(.{});
    var evm = try Evm.init(allocator, &db, block, tx, 0, g.Primitives.ZERO_ADDRESS, .CANCUN);
    defer evm.deinit();
    
    // Contract with various gas costs
    const code = [_]u8{
        // Cheap operations
        0x60, 0x01,  // PUSH1 1 (3 gas)
        0x60, 0x02,  // PUSH1 2 (3 gas)
        0x01,        // ADD (3 gas)
        
        // Medium cost
        0x20,        // SHA3 (30 gas + dynamic)
        
        // Expensive operation
        0x60, 0x00,  // PUSH1 0
        0x60, 0x00,  // PUSH1 0
        0x55,        // SSTORE (20000 gas for new slot)
        
        // Return
        0x60, 0x20, 0x60, 0x00, 0xF3
    };
    
    const code_hash = try db.set_code(&code);
    const contract = g.Primitives.Address.from_u256(0x9999);
    var account = g.Account.zero();
    account.code_hash = code_hash;
    try db.set_account(contract.bytes, account);
    
    // Test with different gas limits
    const gas_limits = [_]u64{ 100, 1000, 50000 };
    
    for (gas_limits) |gas_limit| {
        const params = Evm.CallParams{ .call = .{
            .caller = g.Primitives.ZERO_ADDRESS,
            .to = contract,
            .value = 0,
            .input = &.{},
            .gas = gas_limit,
        } };
        
        const result = evm.call(params);
        const gas_used = gas_limit - result.gas_left;
        
        std.debug.print("Gas limit: {}, Used: {}, Success: {}\n", 
            .{ gas_limit, gas_used, result.success });
    }
}
```

## 🌍 Language Bindings Examples

### C API Example

Using Guillotine from C:

```c filename="c_example.c" showLineNumbers
#include <stdio.h>
#include <string.h>
#include "guillotine.h"

int main() {
    // Initialize EVM
    guillotine_evm_t* evm = guillotine_evm_create();
    if (!evm) {
        fprintf(stderr, "Failed to create EVM\n");
        return 1;
    }
    
    // Simple storage contract
    uint8_t bytecode[] = {
        0x60, 0x42,  // PUSH1 66
        0x60, 0x00,  // PUSH1 0
        0x55,        // SSTORE
        0x60, 0x00,  // PUSH1 0
        0x54,        // SLOAD
        0x60, 0x00,  // PUSH1 0
        0x52,        // MSTORE
        0x60, 0x20,  // PUSH1 32
        0x60, 0x00,  // PUSH1 0
        0xF3         // RETURN
    };
    
    // Execute
    guillotine_result_t result = {0};
    int status = guillotine_execute(evm, bytecode, sizeof(bytecode), &result);
    
    if (status == 0 && result.output_len >= 32) {
        // Read the returned value (big-endian)
        uint64_t value = 0;
        for (int i = 24; i < 32; i++) {
            value = (value << 8) | result.output[i];
        }
        printf("Stored and retrieved value: %llu\n", value);
        printf("Gas used: %llu\n", result.gas_used);
    }
    
    // Cleanup
    if (result.output) {
        guillotine_free_output(result.output);
    }
    guillotine_evm_destroy(evm);
    
    return 0;
}
```

Compile and run:
```bash
gcc -o example c_example.c -L./zig-out/lib -lguillotine -I./zig-out/include
./example
```

### TypeScript/WASM Example (Coming Soon)

```typescript filename="wasm_example.ts" showLineNumbers
import { Guillotine } from '@guillotine/wasm';

async function main() {
    // Initialize WASM module
    const guillotine = await Guillotine.init();
    
    // Create EVM instance
    const evm = guillotine.createEVM({
        hardfork: 'cancun',
        chainId: 1,
    });
    
    // Simple contract: returns 42
    const bytecode = new Uint8Array([
        0x60, 0x2A,  // PUSH1 42
        0x60, 0x00,  // PUSH1 0
        0x52,        // MSTORE
        0x60, 0x20,  // PUSH1 32
        0x60, 0x00,  // PUSH1 0
        0xF3         // RETURN
    ]);
    
    // Execute
    const result = evm.execute(bytecode, {
        gasLimit: 100000,
        caller: '0x0000000000000000000000000000000000000000',
    });
    
    if (result.success) {
        const value = new DataView(result.output.buffer).getBigUint64(24);
        console.log('Returned value:', value); // 42
        console.log('Gas used:', result.gasUsed);
    }
}

main().catch(console.error);
```

## 📊 Performance Examples

### Benchmarking Contract Execution

```zig filename="benchmark.zig" showLineNumbers
const std = @import("std");
const g = @import("guillotine");

pub fn benchmark_execution(allocator: std.mem.Allocator, iterations: u32) !void {
    var db = g.Database.init(allocator);
    defer db.deinit();
    
    var block = g.BlockInfo.init();
    const tx = g.TransactionContext{ .gas_limit = 10_000_000 };
    
    const Evm = g.Evm(.{});
    var evm = try Evm.init(allocator, &db, block, tx, 0, g.Primitives.ZERO_ADDRESS, .CANCUN);
    defer evm.deinit();
    
    // Deploy compute-intensive contract
    const code = [_]u8{
        // Loop that performs SHA3 operations
        0x60, 0x64,  // PUSH1 100 (loop counter)
        0x5B,        // JUMPDEST (loop start)
        0x60, 0x01,  // PUSH1 1
        0x90,        // SWAP1
        0x03,        // SUB
        0x80,        // DUP1
        0x60, 0x20,  // PUSH1 32
        0x52,        // MSTORE
        0x60, 0x20,  // PUSH1 32
        0x60, 0x00,  // PUSH1 0
        0x20,        // SHA3
        0x50,        // POP
        0x80,        // DUP1
        0x60, 0x02,  // PUSH1 2 (jump dest)
        0x57,        // JUMPI
        0x00,        // STOP
    };
    
    const code_hash = try db.set_code(&code);
    const contract = g.Primitives.Address.from_u256(0xBENCH);
    var account = g.Account.zero();
    account.code_hash = code_hash;
    try db.set_account(contract.bytes, account);
    
    // Benchmark
    var timer = try std.time.Timer.start();
    var total_gas: u64 = 0;
    
    var i: u32 = 0;
    while (i < iterations) : (i += 1) {
        const params = Evm.CallParams{ .call = .{
            .caller = g.Primitives.ZERO_ADDRESS,
            .to = contract,
            .value = 0,
            .input = &.{},
            .gas = 1_000_000,
        } };
        
        const result = evm.call(params);
        total_gas += (1_000_000 - result.gas_left);
    }
    
    const elapsed = timer.read();
    const ops_per_sec = @as(f64, @floatFromInt(iterations)) * 1_000_000_000 / 
                        @as(f64, @floatFromInt(elapsed));
    const gas_per_sec = @as(f64, @floatFromInt(total_gas)) * 1_000_000_000 / 
                        @as(f64, @floatFromInt(elapsed));
    
    std.debug.print("Benchmark Results:\n", .{});
    std.debug.print("  Iterations: {}\n", .{iterations});
    std.debug.print("  Total time: {d:.2}ms\n", .{@as(f64, @floatFromInt(elapsed)) / 1_000_000});
    std.debug.print("  Ops/sec: {d:.0}\n", .{ops_per_sec});
    std.debug.print("  Gas/sec: {d:.0}\n", .{gas_per_sec});
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    
    try benchmark_execution(gpa.allocator(), 10000);
}
```

## 🎯 Real-World Patterns

### Contract Factory Pattern

Deploy multiple contracts:

```zig filename="factory.zig" showLineNumbers
const std = @import("std");
const g = @import("guillotine");

const Factory = struct {
    evm: *g.Evm(.{}),
    db: *g.Database,
    next_address: u256,
    
    pub fn deploy_contract(self: *Factory, bytecode: []const u8) !g.Primitives.Address {
        const address = g.Primitives.Address.from_u256(self.next_address);
        self.next_address += 1;
        
        const code_hash = try self.db.set_code(bytecode);
        var account = g.Account.zero();
        account.code_hash = code_hash;
        try self.db.set_account(address.bytes, account);
        
        return address;
    }
    
    pub fn create_token(self: *Factory, initial_supply: u256) !g.Primitives.Address {
        // Simplified token bytecode
        const token_code = [_]u8{
            // ... token implementation
        };
        
        const address = try self.deploy_contract(&token_code);
        
        // Set initial balance
        var account = try self.db.get_account(address.bytes);
        account.balance = initial_supply;
        try self.db.set_account(address.bytes, account);
        
        return address;
    }
};
```

## 💡 Tips & Best Practices

<Callout type="tip">
  **Performance Tips:**
  - Reuse EVM instances when possible
  - Pre-compile bytecode validation
  - Use arena allocators for batch operations
  - Profile with ReleaseFast mode
</Callout>

<Callout type="warning">
  **Common Pitfalls:**
  - Forgetting to call `deinit()` on resources
  - Not checking gas limits before execution
  - Incorrect endianness when reading/writing values
  - Not handling reverts properly
</Callout>

## 📚 More Resources

- **[Full Examples Repository](https://github.com/evmts/Guillotine/tree/main/examples)** - Complete working examples
- **[API Reference](/api/evm)** - Detailed API documentation
- **[Architecture Guide](/advanced/architecture/overview)** - Deep dive into internals
- **[Testing Guide](/advanced/testing/unit)** - Writing tests for your EVM code

---

<div style={{
  padding: '1.5rem',
  background: 'linear-gradient(135deg, rgba(234, 88, 12, 0.05), rgba(220, 38, 38, 0.02))',
  border: '1px solid rgba(234, 88, 12, 0.2)',
  borderRadius: '12px',
  marginTop: '3rem',
  textAlign: 'center'
}}>
  <h3 style={{ marginTop: 0 }}>Have an Example to Share?</h3>
  <p>We welcome community contributions! Share your examples and help others learn.</p>
  <a href="https://github.com/evmts/Guillotine/issues/new" style={{
    display: 'inline-block',
    padding: '0.5rem 1.5rem',
    background: '#EA580C',
    color: 'white',
    borderRadius: '8px',
    textDecoration: 'none',
    marginTop: '1rem'
  }}>
    Submit Example →
  </a>
</div>