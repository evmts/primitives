---
title: FAQ
description: Frequently asked questions about Guillotine
---

import { Callout } from 'vocs/components'

# Frequently Asked Questions

Find answers to common questions about Guillotine, its usage, and development.

## üîç General Questions

### What is Guillotine?

Guillotine is an ultrafast Ethereum Virtual Machine (EVM) implementation written in Zig. It's designed for extreme performance, minimal bundle size, and universal language support. Think of it as a high-performance alternative to existing EVM implementations like Geth's EVM or REVM, but with a focus on:

- **Speed**: Data-oriented design for maximum CPU efficiency
- **Size**: Minimal footprint (~110KB WASM build)
- **Flexibility**: Zero-cost compile-time customization
- **Portability**: Native bindings for multiple languages

### Why is it called "Guillotine"?

The name "Guillotine" was chosen through community brainstorming in our Telegram group. It represents:
- **Clean cuts**: Precise execution of EVM bytecode
- **Swift execution**: Lightning-fast performance
- **Revolutionary**: A new approach to EVM implementation

Credit goes to [@SamBacha](https://github.com/sambacha) for suggesting the winning name!

### Is Guillotine production-ready?

<Callout type="danger">
  **NO** - Guillotine is currently in **early alpha** (v0.1.0) and should NOT be used in production.
</Callout>

Current limitations:
- Missing precompiles (2 of 9)
- No security audit
- API may change
- Known bugs exist

See our [Status page](/status) for details and [Roadmap](/roadmap) for production timeline.

### When will Guillotine be production-ready?

According to our roadmap:
- **Q1 2025**: Beta release (v0.5.0) - Feature complete, stable API
- **Q2 2025**: v1.0 release - Production ready with security audit

### How does Guillotine compare to other EVMs?

| Feature | Guillotine | REVM | Geth | evmone |
|---------|------------|------|------|--------|
| **Language** | Zig | Rust | Go | C++ |
| **Performance** | ‚ö° Fastest* | Fast | Moderate | ‚ö° Fastest |
| **Bundle Size** | ~110KB | ~500KB | ~5MB | ~300KB |
| **Customizable** | ‚úÖ Comptime | ‚úÖ Generics | ‚ùå | ‚ùå |
| **Language Bindings** | Many (planned) | Rust-only | Go-only | C++ |
| **Production Ready** | ‚ùå Alpha | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |

*On average 35% faster than REVM in benchmarks

## üíª Technical Questions

### What makes Guillotine so fast?

Several key optimizations contribute to Guillotine's performance:

1. **Indirect Threading**: Uses tail-call optimization for excellent CPU branch prediction (~25% improvement)
2. **Data-Oriented Design**: Cache-conscious struct layouts minimize memory access
3. **Opcode Fusion**: Common patterns compiled into single operations
4. **Zero-Cost Abstractions**: Zig's comptime eliminates runtime overhead
5. **Assembly Keccak**: Hardware-accelerated cryptography
6. **Batched Operations**: Static gas costs calculated in advance

See our [Architecture Overview](/advanced/architecture/overview) for details.

### Why Zig instead of Rust/C++/Go?

Zig was chosen for several reasons:

| Aspect | Why Zig Wins |
|--------|--------------|
| **Performance** | Manual memory control, no hidden allocations |
| **Comptime** | Zero-cost customization without complex generics |
| **Simplicity** | No hidden control flow, easier to optimize |
| **C Interop** | Seamless C ABI compatibility |
| **Cross-compilation** | Built-in cross-compilation support |
| **Size** | Minimal runtime, excellent dead code elimination |

### What is comptime customization?

Zig's `comptime` allows compile-time code execution and configuration:

```zig
// Configuration evaluated at compile time
const config = EvmConfig{
    .hardfork = .SHANGHAI,  // Only Shanghai code included
    .enable_trace = false,   // Tracing code eliminated
    .max_stack = 512,        // Stack size optimized
};

// Creates a custom EVM type with only needed features
const MyEvm = Evm(config);
```

Result: Your binary only includes code for features you actually use.

### How do I customize Guillotine for my needs?

```zig
const CustomConfig = EvmConfig{
    // Choose hardfork
    .hardfork = .CANCUN,
    
    // Add custom opcodes
    .custom_opcodes = &[_]Opcode{
        .{ .code = 0xF5, .handler = my_custom_handler },
    },
    
    // Add custom precompiles
    .custom_precompiles = &[_]Precompile{
        .{ .address = 0x100, .execute = my_precompile },
    },
    
    // Adjust limits
    .max_call_depth = 512,
    .max_code_size = 0x8000,
};

const CustomEvm = Evm(CustomConfig);
```

## üõ†Ô∏è Usage Questions

### How do I install Guillotine?

Currently, you must build from source:

```bash
# Clone repository
git clone https://github.com/evmts/Guillotine.git
cd Guillotine

# Build with Zig
zig build

# Run tests
zig build test
```

See [Installation Guide](/getting-started/installation) for detailed instructions.

### Can I use Guillotine from TypeScript/Python/Go?

Language binding status:

| Language | Status | Usage |
|----------|--------|-------|
| **Zig** | ‚úÖ Native | Direct import |
| **C** | ‚úÖ Complete | Via header file |
| **TypeScript** | üöß In Progress | WASM build (Q1 2025) |
| **Go** | üöß In Progress | CGO bindings (Q1 2025) |
| **Python** | üìÖ Planned | Via ctypes (Q2 2025) |
| **Rust** | üìÖ Planned | FFI (Q2 2025) |

### How do I execute bytecode?

Basic example:

```zig
// Initialize EVM
const Evm = guillotine.Evm(.{});
var evm = try Evm.init(allocator);
defer evm.deinit();

// Execute bytecode
const bytecode = [_]u8{ 0x60, 0x42 }; // PUSH1 42
const result = try evm.execute(&bytecode);

// Check result
std.debug.print("Stack top: {}\n", .{result.stack_top}); // 42
```

See [Quick Start](/getting-started/quick-start) for more examples.

### How do I run differential tests?

Differential testing compares Guillotine against REVM:

```bash
# Run differential tests
zig build test-differential

# With specific test case
zig build test-differential -- --filter "erc20"
```

### What's the difference between build modes?

| Mode | Use Case | Safety | Performance | Size |
|------|----------|--------|-------------|------|
| **Debug** | Development | Maximum | Slowest | Largest |
| **ReleaseSafe** | Alpha/Beta testing | High | Fast | Medium |
| **ReleaseFast** | Benchmarking | Minimal | Fastest | Medium |
| **ReleaseSmall** | Embedded | Minimal | Good | Smallest |

We recommend `ReleaseSafe` during alpha.

## ‚ùó Troubleshooting

### Build fails with "OutOfMemory"

**Solution**: Increase available memory or use ReleaseSmall:
```bash
zig build -Doptimize=ReleaseSmall
```

### "Zig version incompatible"

**Solution**: Ensure you have Zig 0.14.1 or later:
```bash
zig version  # Should show 0.14.1 or higher
```

### Tests fail on Windows

**Known issue**: Windows support is experimental. Use WSL as a workaround:
```bash
# In WSL
zig build test
```

### WASM build performance is poor

**Known issue**: WASM is 30% slower than native. Optimizations coming in Beta.

### How do I report a bug?

1. Check [existing issues](https://github.com/evmts/Guillotine/issues)
2. Create a [minimal reproduction](https://stackoverflow.com/help/minimal-reproducible-example)
3. Open a [new issue](https://github.com/evmts/Guillotine/issues/new) with:
   - Zig version
   - Platform/OS
   - Steps to reproduce
   - Expected vs actual behavior

## ü§ù Contributing Questions

### How can I contribute?

We welcome all contributions! Areas where we need help:

- **Testing**: Write tests, improve coverage
- **Documentation**: Fix typos, add examples
- **Performance**: Profile and optimize
- **Language Bindings**: Implement TypeScript, Go, Python bindings
- **Bug Fixes**: Pick an issue and fix it

See [Contributing Guide](/contributing/setup) for details.

### Do you accept AI-assisted contributions?

Yes! We welcome AI-assisted contributions with proper disclosure. Just mention in your PR if you used AI assistance.

### What's the development setup?

```bash
# Clone repo
git clone https://github.com/evmts/Guillotine.git
cd Guillotine

# Install Zig 0.14.1+
# See https://ziglang.org/download/

# Build
zig build

# Test
zig build test

# Run specific test
zig build test -- --filter "stack"
```

### How do I run benchmarks?

```bash
# Run all benchmarks
zig build benchmark

# Run specific benchmark
zig build benchmark -- --filter "erc20"

# Compare with REVM
zig build benchmark-compare
```

## üèóÔ∏è Architecture Questions

### What is indirect threading?

Traditional interpreters use a central switch statement:
```zig
// Poor branch prediction
while (true) {
    switch (opcode) {
        0x01 => add(),
        0x02 => mul(),
        // ...
    }
}
```

Guillotine uses tail calls:
```zig
// Excellent branch prediction
pub fn add(self: *Frame) Error!void {
    // ... perform addition ...
    return self.dispatch_next(); // Tail call
}
```

Result: CPU can predict branches better, ~25% performance gain.

### What is opcode fusion?

Common opcode patterns are combined into single operations:

```zig
// Pattern: PUSH1 0x20 + ADD (common in loops)
// Instead of two dispatches, we have one:
pub fn push1_0x20_add(self: *Frame) Error!void {
    const top = self.stack.peek_unsafe();
    self.stack.set_top_unsafe(top + 0x20);
    return self.dispatch_next();
}
```

### How does memory management work?

Guillotine uses arena allocation for transaction-scoped memory:

1. **Pre-allocation**: Reserve initial capacity
2. **Bulk operations**: All allocations through arena
3. **Automatic cleanup**: Everything freed at transaction end

```zig
var arena = ArenaAllocator.init(allocator);
defer arena.deinit(); // Automatic cleanup

// All allocations use arena
const memory = try arena.alloc(u8, size);
// No individual frees needed
```

## üîÆ Future Questions

### Will there be a JIT compiler?

Yes, planned for v2.0:
- Selective JIT for hot contracts
- Expected 50% performance boost
- Seamless integration with interpreter

### Will Guillotine become a full client?

Yes, the Tevm team plans to build a full Ethereum client using Guillotine as the VM. Features will include:
- Parallel transaction execution
- I/O optimized architecture
- State-of-the-art performance

### Will there be a GUI debugger?

Yes, planned for v1.0:
- Step-through debugging
- State inspection
- Gas profiling
- Transaction replay

### What about Layer 2 support?

Guillotine is designed to be flexible enough for L2s:
- Custom opcodes for L2-specific operations
- Configurable gas schedules
- Pluggable state backends

## üìö Resources

### Where can I learn more?

- **[Documentation](/)** - You're here!
- **[GitHub](https://github.com/evmts/Guillotine)** - Source code
- **[Examples](/examples)** - Code samples
- **[API Reference](/api/evm)** - Detailed API docs
- **[Architecture](/advanced/architecture/overview)** - Technical deep dive

### How do I get help?

- **[Telegram](https://t.me/+ANThR9bHDLAwMjUx)** - Quick questions
- **[Discord](https://discord.gg/guillotine)** - Community chat
- **[GitHub Issues](https://github.com/evmts/Guillotine/issues)** - Bug reports
- **[GitHub Discussions](https://github.com/evmts/Guillotine/discussions)** - Feature requests

---

<div style={{
  padding: '1.5rem',
  background: 'linear-gradient(135deg, rgba(234, 88, 12, 0.05), rgba(220, 38, 38, 0.02))',
  border: '1px solid rgba(234, 88, 12, 0.2)',
  borderRadius: '12px',
  marginTop: '3rem',
  textAlign: 'center'
}}>
  <h3 style={{ marginTop: 0 }}>Still have questions?</h3>
  <p>Join our community and get help from the team and other developers.</p>
  <div style={{ display: 'flex', gap: '1rem', justifyContent: 'center', marginTop: '1rem' }}>
    <a href="https://t.me/+ANThR9bHDLAwMjUx" style={{
      padding: '0.5rem 1rem',
      background: '#EA580C',
      color: 'white',
      borderRadius: '8px',
      textDecoration: 'none'
    }}>
      Join Telegram ‚Üí
    </a>
    <a href="https://github.com/evmts/Guillotine/discussions" style={{
      padding: '0.5rem 1rem',
      border: '1px solid #EA580C',
      color: '#EA580C',
      borderRadius: '8px',
      textDecoration: 'none'
    }}>
      Start Discussion ‚Üí
    </a>
  </div>
</div>