---
title: EVM API
description: Complete API reference for the Guillotine EVM
---

# EVM API Reference

Guillotine exposes a strongly typed API centered around two types: `Evm` (the engine) and `Database` (state). This page documents how to construct the EVM, execute calls, and interpret results.

## Constructing an EVM

```zig
const g = @import("guillotine");

// Compile-time config
const config = g.EvmConfig{};
const Evm = g.Evm(config);

// Runtime context
var db = g.Database.init(allocator);
defer db.deinit();
var block = g.BlockInfo.init();
const tx = g.TransactionContext{ .gas_limit = 3_000_000, .coinbase = g.Primitives.ZERO_ADDRESS, .chain_id = 1 };
const origin = g.Primitives.ZERO_ADDRESS;

// Initialize
var evm = try Evm.init(allocator, &db, block, tx, /*gas_price=*/0, origin, config.eips.hardfork);
defer evm.deinit();
```

## Executing calls

All execution goes through `call` (or `simulate` for dry-runs). The parameter type is specialized per EVM config: `Evm.CallParams`.

```zig
const CallParams = Evm.CallParams;

// CALL
const call_params = CallParams{ .call = .{ .caller = origin, .to = target, .value = 0, .input = calldata, .gas = 500_000 } };
const call_result = evm.call(call_params);

// STATICCALL
const static_params = CallParams{ .staticcall = .{ .caller = origin, .to = target, .input = calldata, .gas = 200_000 } };
const static_result = evm.call(static_params);

// DELEGATECALL
const delegate_params = CallParams{ .delegatecall = .{ .caller = origin, .to = implementation, .input = calldata, .gas = 300_000 } };
const delegate_result = evm.call(delegate_params);

// CREATE / CREATE2
const create_params = CallParams{ .create = .{ .caller = origin, .value = 0, .init_code = init_code, .gas = 1_000_000 } };
const create_result = evm.call(create_params);
if (create_result.success and create_result.created_address) |addr| {
  // new contract address
}

// Dry-run with no state changes
const preview = evm.simulate(call_params);
```

## Parameters and results

### CallParams (union)

```zig
const CallParams = Evm.CallParams; // union(enum) with these tags:
// .call        { caller, to, value, input, gas }
// .callcode    { caller, to, value, input, gas }
// .delegatecall{ caller, to, input, gas }
// .staticcall  { caller, to, input, gas }
// .create      { caller, value, init_code, gas }
// .create2     { caller, value, init_code, salt, gas }

// Helpers
_ = CallParams.getGas;     // returns u64
_ = CallParams.getCaller;  // returns Address
_ = CallParams.getInput;   // returns []const u8
```

### CallResult (struct)

```zig
const CallResult = Evm.CallResult;
// Fields (subset):
// success: bool
// gas_left: u64
// output: []const u8      // return or revert data
// created_address: ?Address
// logs, selfdestructs, accessed_addresses, accessed_storage, trace, error_info

// Convenience constructors exist internally; you consume the fields above.
```

## State access

Use the `Database` you passed to `Evm.init` for accounts, storage, and code:

```zig
// Accounts
const maybe_acc = try db.get_account(addr.bytes);
var acc = maybe_acc orelse g.Account.zero();
try db.set_account(addr.bytes, acc);

// Storage
try db.set_storage(contract.bytes, key, value);
const val = try db.get_storage(contract.bytes, key);

// Code
const code_hash = try db.set_code(&bytecode);
const code = try db.get_code_by_address(contract.bytes);
```

## EVM lifecycle

- `init` creates an instance; call `deinit` to free internal resources
- Top-level `call` resets per-tx state (journal, access list, logs)
- `simulate` runs the same logic but always rolls back state changes

## Notes

- Errors from allocator/database APIs still use Zig error unions and must be handled with `try`
- Execution failures use `CallResult` with `success=false`
- Gas usage can be derived as `params.getGas() - result.gas_left`

### Error Handling Patterns

```zig
// Explicit error handling
evm.execute(bytecode) catch |err| switch (err) {
    error.OutOfGas => {
        // Handle out of gas
    },
    error.RevertExecution => {
        // Handle revert
    },
    else => return err,
};

// Try pattern
const result = try evm.execute(bytecode);

// Error union
const result = evm.execute(bytecode);
if (result) |success| {
    // Handle success
} else |err| {
    // Handle error
}
```

## Gas Management

### Gas Tracking

```zig
// Get remaining gas
const gas_left = evm.getGasLeft();

// Check gas consumption
const gas_used = evm.getGasUsed();

// Set gas limit
evm.setGasLimit(3000000);
```

### Gas Costs

```zig
// Calculate call gas
const gas_cost = evm.calculateCallGas(params);

// Calculate memory expansion gas
const mem_gas = evm.calculateMemoryGas(new_size);

// Calculate storage gas
const storage_gas = evm.calculateStorageGas(operation);
```

## Tracing and Debugging

### Enable Tracing

```zig
const TracedEvm = Evm(EvmConfig{
    .TracerType = MyTracer,
    // ... other config
});
```

### Tracer Interface

```zig
pub const Tracer = struct {
    pub fn on_opcode(self: *Tracer, pc: usize, opcode: u8, gas: u64) void;
    pub fn on_call(self: *Tracer, params: CallParams) void;
    pub fn on_return(self: *Tracer, data: []const u8) void;
    pub fn on_revert(self: *Tracer, reason: []const u8) void;
    pub fn on_storage(self: *Tracer, address: Address, key: U256, value: U256) void;
};
```

## Precompiled Contracts

### Available Precompiles

| Address | Name | Description |
|---------|------|-------------|
| `0x01` | ECRECOVER | Elliptic curve recovery |
| `0x02` | SHA256 | SHA-256 hash |
| `0x03` | RIPEMD160 | RIPEMD-160 hash |
| `0x04` | IDENTITY | Identity function |
| `0x05` | MODEXP | Modular exponentiation |
| `0x06` | ECADD | Elliptic curve addition |
| `0x07` | ECMUL | Elliptic curve multiplication |
| `0x08` | ECPAIRING | Elliptic curve pairing |
| `0x09` | BLAKE2F | BLAKE2F compression |

### Calling Precompiles

```zig
const result = try evm.callPrecompile(
    address,    // Precompile address
    input,      // Input data
    gas,        // Gas limit
);
```

## Advanced Features

### Opcode Fusion

When enabled, common patterns are optimized:

```zig
// These patterns are fused:
// PUSH1 + ADD
// PUSH1 + MUL
// DUP1 + SWAP1
// And more...

const config = EvmConfig{
    .enable_fusion = true,  // Enable fusion
};
```

### Custom Database

```zig
const MyDatabase = struct {
    pub fn get_account(self: *MyDatabase, address: Address) ?Account {
        // Custom implementation
    }
    
    pub fn set_account(self: *MyDatabase, address: Address, account: Account) void {
        // Custom implementation
    }
    
    // ... other methods
};

const config = EvmConfig{
    .DatabaseType = MyDatabase,
};
```

### Memory Optimization

```zig
// Use arena allocator for transaction scope
var arena = GrowingArenaAllocator.init(
    allocator,
    32 * 1024,  // 32KB initial
    150,        // 50% growth
);
defer arena.deinit();

var evm = try MyEvm.init(arena.allocator());
```

## Performance Tips

1. **Use appropriate build mode**
   ```bash
   zig build -Doptimize=ReleaseFast  # Maximum performance
   zig build -Doptimize=ReleaseSafe  # Production with safety
   ```

2. **Configure for your use case**
   - Disable unused features (precompiles, fusion)
   - Set appropriate limits (stack size, memory)
   - Choose correct hardfork

3. **Optimize memory usage**
   - Use arena allocator
   - Set appropriate initial capacity
   - Reuse EVM instances when possible

4. **Batch operations**
   - Group related calls
   - Use transaction batching
   - Minimize state queries

## Example: Complete Transaction

```zig
const std = @import("std");
const Evm = @import("evm").Evm;
const EvmConfig = @import("evm").EvmConfig;

pub fn executeTransaction(allocator: Allocator) !void {
    // Configure EVM
    const config = EvmConfig{
        .eips = Eips{ .hardfork = Hardfork.CANCUN },
        .enable_precompiles = true,
        .enable_fusion = true,
    };
    const MyEvm = Evm(config);
    
    // Initialize with arena allocator
    var arena = GrowingArenaAllocator.init(allocator, 32 * 1024, 150);
    defer arena.deinit();
    
    var evm = try MyEvm.init(arena.allocator());
    defer evm.deinit();
    
    // Set transaction context
    evm.setTransactionContext(.{
        .origin = sender_address,
        .gas_price = 20_000_000_000,
        .block_number = 18_000_000,
        .timestamp = 1700000000,
        .gas_limit = 3_000_000,
        .chain_id = 1,
    });
    
    // Execute call
    const result = try evm.call(.{
        .caller = sender_address,
        .target = contract_address,
        .value = 0,
        .data = call_data,
        .gas = 1_000_000,
        .is_static = false,
    });
    
    // Handle result
    switch (result) {
        .success => |data| {
            std.debug.print("Success: {x}\n", .{data});
        },
        .revert => |reason| {
            std.debug.print("Reverted: {s}\n", .{reason});
        },
    }
}
```

## Next Steps

- Learn about [Customizing Opcodes](/advanced/customization/opcodes)
- Explore [State Management](#TODO)
- Understand [Architecture](/advanced/architecture/overview)
