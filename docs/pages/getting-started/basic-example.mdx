---
title: Basic Example
description: "End-to-end example: load code, call with calldata, inspect results"
---

# Basic Example

This example shows how to deploy simple code, send calldata, and interpret the result.

:::info[What you'll learn]
- Initialize EVM with context
- Install code and attach it to an account
- Build calldata and call
- Inspect success, output, and gas
:::

```zig filename="src/main.zig"
const std = @import("std");
const g = @import("guillotine");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // State and context
    var db = g.Database.init(allocator);
    defer db.deinit();

    var block = g.BlockInfo.init();
    const tx = g.TransactionContext{ .gas_limit = 2_000_000, .coinbase = g.Primitives.ZERO_ADDRESS, .chain_id = 1 };
    const origin = g.Primitives.ZERO_ADDRESS;

    // EVM
    const config = g.EvmConfig{};
    const Evm = g.Evm(config);
    var evm = try Evm.init(allocator, &db, block, tx, 0, origin, config.eips.hardfork);
    defer evm.deinit();

    // Deploy tiny program that echoes first 32 bytes of input
    const code = [_]u8{ 0x36, 0x60, 0x20, 0x10, 0x60, 0x00, 0x52, 0x60, 0x20, 0x60, 0x00, 0xF3 };
    const code_hash = try db.set_code(&code);
    const contract = g.Primitives.Address.from_u256(0xBEE);
    var acc = g.Account.zero();
    acc.code_hash = code_hash;
    try db.set_account(contract.bytes, acc);

    // Build calldata (32-byte big-endian value 123)
    var buf: [32]u8 = .{0} ** 32;
    std.mem.writeInt(u256, &buf, 123, .big);

    // Call
    const CallParams = Evm.CallParams;
    const params = CallParams{ .call = .{ .caller = origin, .to = contract, .value = 0, .input = &buf, .gas = 200_000 } };
    const result = evm.call(params);

    if (result.success and result.output.len >= 32) {
        const value = std.mem.readInt(u256, result.output[0..32], .big);
        const used = params.getGas() -| result.gas_left;
        std.debug.print("ok value={} gas_used={}\n", .{ value, used });
    } else {
        std.debug.print("failed gas_left={} bytes={}\n", .{ result.gas_left, result.output.len });
    }
}
```

### Notes

- Examples use the in-memory `Database` provided by Guillotine
- For real-world usage, hydrate state from your own source of truth
- Use `simulate` to preview effects and gas without committing changes
