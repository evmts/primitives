---
title: Quick Start
description: Run your first EVM call with Guillotine using the real API
---

import { Callout } from 'vocs/components'

# Quick Start

This guide uses the actual Guillotine EVM API. You will initialize the EVM, load code into state, and execute a call.

<Callout type="info">
  Prerequisites: Zig 0.14.1+ and [Guillotine installed](/getting-started/installation).
</Callout>

## 1) Create a new Zig project

```bash
mkdir guillotine-quickstart
cd guillotine-quickstart
zig init
```

## 2) Add Guillotine as a dependency

Edit `build.zig.zon` and add a local dependency:

```zig filename="build.zig.zon"
.{
    .name = "guillotine-quickstart",
    .version = "0.0.1",
    .dependencies = .{
        .guillotine = .{ .path = "../Guillotine" }, // adjust path
    },
}
```

Then wire it up in `build.zig`:

```zig filename="build.zig"
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "guillotine-quickstart",
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });

    const guillotine = b.dependency("guillotine", .{ .target = target, .optimize = optimize });
    exe.root_module.addImport("guillotine", guillotine.module("guillotine"));

    b.installArtifact(exe);

    const run_cmd = b.addRunArtifact(exe);
    run_cmd.step.dependOn(b.getInstallStep());
    const run_step = b.step("run", "Run the app");
    run_step.dependOn(&run_cmd.step);
}
```

## 3) Write your first EVM call

Replace `src/main.zig` with:

```zig filename="src/main.zig"
const std = @import("std");
const g = @import("guillotine");

pub fn main() !void {
    // Allocator
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // In-memory state database
    var db = g.Database.init(allocator);
    defer db.deinit();

    // Minimal block + tx context
    var block = g.BlockInfo.init();
    block.number = 18_000_000;
    block.timestamp = 1_700_000_000;
    const tx = g.TransactionContext{
        .gas_limit = 1_000_000,
        .coinbase = g.Primitives.ZERO_ADDRESS,
        .chain_id = 1,
    };

    // Create EVM instance type and initialize
    const config = g.EvmConfig{};
    const Evm = g.Evm(config);
    const origin = g.Primitives.ZERO_ADDRESS;
    var evm = try Evm.init(allocator, &db, block, tx, 0, origin, config.eips.hardfork);
    defer evm.deinit();

    // Install a small program that returns 32-byte value 42
    const code = [_]u8{ 0x60, 0x2A, 0x60, 0x00, 0x52, 0x60, 0x20, 0x60, 0x00, 0xF3 };
    const code_hash = try db.set_code(&code);
    const contract = g.Primitives.Address.from_u256(0xC0FFEE);
    var account = g.Account.zero();
    account.code_hash = code_hash;
    try db.set_account(contract.bytes, account);

    // Call the contract
    const CallParams = Evm.CallParams;
    const params = CallParams{ .call = .{
        .caller = origin,
        .to = contract,
        .value = 0,
        .input = &.{},
        .gas = 100_000,
    } };

    const result = evm.call(params);
    if (result.success and result.output.len >= 32) {
        const value = std.mem.readInt(u256, result.output[0..32], .big);
        std.debug.print("Success. Returned: {}\n", .{value});
        std.debug.print("Gas left: {}\n", .{result.gas_left});
    } else {
        std.debug.print("Call failed. Gas left: {}\n", .{result.gas_left});
    }
}
```

## 4) Run it

```bash
zig build run
```

You should see output similar to:

```
Success. Returned: 42
Gas left: 999xx
```

That‚Äôs it! You‚Äôve initialized the EVM, installed code into state, and executed a call using the real API.

```zig filename="memory.zig" showLineNumbers
const bytecode = [_]u8{
    // Store 0xFF at memory position 0
    0x60, 0xFF,  // PUSH1 255
    0x60, 0x00,  // PUSH1 0 (memory position)
    0x52,        // MSTORE
    
    // Load from memory position 0
    0x60, 0x00,  // PUSH1 0
    0x51,        // MLOAD
};

const result = try evm.execute(&bytecode);
std.debug.print("Memory value: {x}\n", .{result.stack_top});
```

## üîß Advanced Usage

### Custom Configuration

Configure the EVM for specific needs:

```zig filename="custom_config.zig" twoslash
const config = guillotine.EvmConfig{
    .hardfork = .SHANGHAI,      // Use Shanghai hardfork rules
    .enable_trace = true,        // Enable execution tracing
    .max_call_depth = 512,       // Custom call depth limit
    .max_code_size = 0x6000,     // 24KB max contract size
};

const CustomEvm = guillotine.Evm(config);
var evm = try CustomEvm.init(allocator);
defer evm.deinit();
```

### Error Handling

Properly handle execution errors:

```zig filename="error_handling.zig"
const result = evm.execute(&bytecode) catch |err| {
    switch (err) {
        error.OutOfGas => {
            std.debug.print("‚õΩ Out of gas!\n", .{});
            return;
        },
        error.StackUnderflow => {
            std.debug.print("üìâ Stack underflow!\n", .{});
            return;
        },
        error.InvalidOpcode => {
            std.debug.print("‚ùå Invalid opcode!\n", .{});
            return;
        },
        else => return err,
    }
};
```

### With Gas Limit

Execute with specific gas limit:

```zig filename="gas_limit.zig"
var tx_context = guillotine.TxContext{
    .gas_limit = 30000,
    .gas_price = 20_000_000_000, // 20 gwei
    .origin = guillotine.Address.zero(),
    .block_number = 18_500_000,
};

const result = try evm.execute_with_context(&bytecode, &tx_context);
std.debug.print("Gas remaining: {}\n", .{tx_context.gas_limit - result.gas_used});
```

## üåç Language Bindings

### C Example

Using Guillotine from C:

```c filename="main.c" showLineNumbers
#include <stdio.h>
#include "guillotine.h"

int main() {
    // Create EVM instance
    guillotine_evm_t* evm = guillotine_evm_create();
    if (!evm) {
        fprintf(stderr, "Failed to create EVM\n");
        return 1;
    }
    
    // Bytecode: PUSH1 42
    uint8_t bytecode[] = {0x60, 0x2A};
    
    // Execute
    guillotine_result_t result = {0};
    int status = guillotine_execute(evm, bytecode, sizeof(bytecode), &result);
    
    if (status == 0) {
        printf("Success! Stack top: %llu\n", result.stack_top);
        printf("Gas used: %llu\n", result.gas_used);
    } else {
        printf("Execution failed with error: %d\n", status);
    }
    
    // Cleanup
    guillotine_evm_destroy(evm);
    return 0;
}
```

Compile and run:
```bash
# Build Guillotine C library
cd Guillotine && zig build c-api

# Compile your program
gcc -o my_evm main.c \
    -L./zig-out/lib -lguillotine \
    -I./zig-out/include

# Run
./my_evm
```

## üìä Performance Tips

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem', marginBottom: '2rem' }}>
  <div style={{
    padding: '1rem',
    background: 'var(--vocs-color_background2)',
    border: '1px solid var(--vocs-color_border)',
    borderRadius: '8px'
  }}>
    <h4 style={{ marginTop: 0, color: '#10B981' }}>‚úÖ Do</h4>
    <ul style={{ margin: 0 }}>
      <li>Pre-validate bytecode when possible</li>
      <li>Reuse EVM instances for multiple executions</li>
      <li>Use arena allocators for batch operations</li>
      <li>Profile with ReleaseFast mode</li>
    </ul>
  </div>
  
  <div style={{
    padding: '1rem',
    background: 'var(--vocs-color_background2)',
    border: '1px solid var(--vocs-color_border)',
    borderRadius: '8px'
  }}>
    <h4 style={{ marginTop: 0, color: '#EF4444' }}>‚ùå Don't</h4>
    <ul style={{ margin: 0 }}>
      <li>Create new EVM for each execution</li>
      <li>Forget to call deinit()</li>
      <li>Use Debug mode in production</li>
      <li>Ignore error handling</li>
    </ul>
  </div>
</div>

## üéÆ Interactive Playground

Try these bytecode snippets in your program:

:::code-group

```zig [Multiplication]
// Calculate: 7 * 8
const bytecode = [_]u8{
    0x60, 0x07,  // PUSH1 7
    0x60, 0x08,  // PUSH1 8
    0x02,        // MUL
};
// Result: 56
```

```zig [Comparison]
// Check if 10 > 5
const bytecode = [_]u8{
    0x60, 0x05,  // PUSH1 5
    0x60, 0x0A,  // PUSH1 10
    0x11,        // GT (greater than)
};
// Result: 1 (true)
```

```zig [Bitwise]
// Calculate: 0xFF AND 0x0F
const bytecode = [_]u8{
    0x60, 0xFF,  // PUSH1 255
    0x60, 0x0F,  // PUSH1 15
    0x16,        // AND
};
// Result: 15 (0x0F)
```

:::

## üìö Quick Reference

### Common Opcodes

| Opcode | Hex | Gas | Stack | Description |
|--------|-----|-----|-------|-------------|
| `STOP` | `0x00` | 0 | 0 ‚Üí 0 | Halt execution |
| `ADD` | `0x01` | 3 | 2 ‚Üí 1 | Addition |
| `MUL` | `0x02` | 5 | 2 ‚Üí 1 | Multiplication |
| `SUB` | `0x03` | 3 | 2 ‚Üí 1 | Subtraction |
| `DIV` | `0x04` | 5 | 2 ‚Üí 1 | Division |
| `LT` | `0x10` | 3 | 2 ‚Üí 1 | Less than |
| `GT` | `0x11` | 3 | 2 ‚Üí 1 | Greater than |
| `EQ` | `0x14` | 3 | 2 ‚Üí 1 | Equality |
| `AND` | `0x16` | 3 | 2 ‚Üí 1 | Bitwise AND |
| `OR` | `0x17` | 3 | 2 ‚Üí 1 | Bitwise OR |
| `PUSH1` | `0x60` | 3 | 0 ‚Üí 1 | Push 1 byte |
| `DUP1` | `0x80` | 3 | 1 ‚Üí 2 | Duplicate top |
| `SWAP1` | `0x90` | 3 | 2 ‚Üí 2 | Swap top two |

### Error Codes

| Error | Description | Common Cause |
|-------|-------------|--------------|
| `OutOfGas` | Insufficient gas | Gas limit too low |
| `StackUnderflow` | Pop from empty stack | Missing PUSH operation |
| `StackOverflow` | Stack exceeds 1024 | Too many values pushed |
| `InvalidOpcode` | Unknown instruction | Corrupted bytecode |
| `InvalidJump` | Jump to non-JUMPDEST | Incorrect jump target |

## üöÄ Next Steps

Now that you're executing EVM bytecode:

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem', marginTop: '2rem' }}>
  <a href="/getting-started/basic-example" style={{
    display: 'block',
    padding: '1.5rem',
    background: 'linear-gradient(135deg, rgba(234, 88, 12, 0.1), rgba(220, 38, 38, 0.05))',
    border: '1px solid rgba(234, 88, 12, 0.3)',
    borderRadius: '12px',
    textDecoration: 'none'
  }}>
    <h3 style={{ margin: '0 0 0.5rem 0' }}>üìò Basic Example</h3>
    <p style={{ margin: 0, color: 'var(--vocs-color_text2)' }}>
      Complete contract execution with deployment and calls
    </p>
  </a>
  
  <a href="/usage/basic-execution" style={{
    display: 'block',
    padding: '1.5rem',
    background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.05))',
    border: '1px solid rgba(59, 130, 246, 0.3)',
    borderRadius: '12px',
    textDecoration: 'none'
  }}>
    <h3 style={{ margin: '0 0 0.5rem 0' }}>‚öôÔ∏è Execution Modes</h3>
    <p style={{ margin: 0, color: 'var(--vocs-color_text2)' }}>
      Learn about different execution contexts and modes
    </p>
  </a>
  
  <a href="/api/evm" style={{
    display: 'block',
    padding: '1.5rem',
    background: 'linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05))',
    border: '1px solid rgba(16, 185, 129, 0.3)',
    borderRadius: '12px',
    textDecoration: 'none'
  }}>
    <h3 style={{ margin: '0 0 0.5rem 0' }}>üìö API Reference</h3>
    <p style={{ margin: 0, color: 'var(--vocs-color_text2)' }}>
      Complete API documentation with examples
    </p>
  </a>
  
  <a href="/advanced/performance/optimization" style={{
    display: 'block',
    padding: '1.5rem',
    background: 'linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(139, 92, 246, 0.05))',
    border: '1px solid rgba(168, 85, 247, 0.3)',
    borderRadius: '12px',
    textDecoration: 'none'
  }}>
    <h3 style={{ margin: '0 0 0.5rem 0' }}>üöÄ Optimization</h3>
    <p style={{ margin: 0, color: 'var(--vocs-color_text2)' }}>
      Advanced performance tuning techniques
    </p>
  </a>
</div>

## üí¨ Get Help

<Callout type="info">
  **Need assistance?** 
  - üìñ Browse [examples](https://github.com/evmts/Guillotine/tree/main/examples)
  - üí¨ Join our [Telegram community](https://t.me/+ANThR9bHDLAwMjUx)
  - üêõ Report [issues on GitHub](https://github.com/evmts/Guillotine/issues)
  - üéÆ Chat on [Discord](https://discord.gg/guillotine)
</Callout>
