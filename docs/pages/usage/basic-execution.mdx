---
title: Basic Execution
description: Learn how to execute calls and contract creation with Guillotineâ€™s real API
---

# Basic Execution

Guillotine executes calls against state stored in a Database. You install bytecode into an account, then invoke it via `call`. Use `simulate` to run without committing state changes.

## Execution Modes

### Direct Call

Call code stored at an address:

```zig
// Install code
const code = [_]u8{ 0x60, 0x2A, 0x60, 0x00, 0x52, 0x60, 0x20, 0x60, 0x00, 0xF3 };
const code_hash = try db.set_code(&code);
const target = g.Primitives.Address.from_u256(0xABCD);
var account = g.Account.zero();
account.code_hash = code_hash;
try db.set_account(target.bytes, account);

// Build params and call
const CallParams = Evm.CallParams;
const params = CallParams{ .call = .{
  .caller = origin,
  .to = target,
  .value = 0,
  .input = &.{},
  .gas = 200_000,
} };
const result = evm.call(params);
```

### Calldata Calls

Execute a function by sending calldata:

```zig
const input = &[_]u8{ 0xa9, 0x05, 0x9c, 0xbb } ++ encoded_args; // transfer(address,uint256)
const params = CallParams{ .call = .{
  .caller = origin,
  .to = token,
  .value = 0,
  .input = input,
  .gas = 500_000,
} };
const result = evm.call(params);
```

### Contract Creation

Create contracts via `create` or `create2` call params:

```zig
const params = CallParams{ .create = .{
  .caller = deployer,
  .value = 0,
  .init_code = init_code,
  .gas = 1_000_000,
} };
const result = evm.call(params);
if (result.success and result.created_address) |addr| {
  // addr is the new contract address
}
```

## Working with Bytecode

### Simple Operations

:::code-group

```zig [Addition]
// 3 + 5 = 8
const bytecode = [_]u8{
    0x60, 0x03,  // PUSH1 3
    0x60, 0x05,  // PUSH1 5
    0x01,        // ADD
};
```

```zig [Multiplication]
// 4 * 7 = 28
const bytecode = [_]u8{
    0x60, 0x04,  // PUSH1 4
    0x60, 0x07,  // PUSH1 7
    0x02,        // MUL
};
```

```zig [Comparison]
// 10 > 5 = 1 (true)
const bytecode = [_]u8{
    0x60, 0x0A,  // PUSH1 10
    0x60, 0x05,  // PUSH1 5
    0x11,        // GT
};
```

:::

### Memory Operations

```zig
// Store and load from memory
const bytecode = [_]u8{
    0x60, 0x42,  // PUSH1 66 (value)
    0x60, 0x00,  // PUSH1 0 (offset)
    0x52,        // MSTORE
    0x60, 0x00,  // PUSH1 0 (offset)
    0x51,        // MLOAD
};
```

### Storage Operations

```zig
// Persistent storage
const bytecode = [_]u8{
    0x60, 0x99,  // PUSH1 153 (value)
    0x60, 0x01,  // PUSH1 1 (key)
    0x55,        // SSTORE
    0x60, 0x01,  // PUSH1 1 (key)
    0x54,        // SLOAD
};
```

## Execution Context

EVM initialization requires explicit block and transaction context:

```zig
var block = g.BlockInfo.init();
block.number = 18_000_000;
block.timestamp = 1_700_000_000;
const tx = g.TransactionContext{
  .gas_limit = 3_000_000,
  .coinbase = g.Primitives.ZERO_ADDRESS,
  .chain_id = 1,
};
var evm = try Evm.init(allocator, &db, block, tx, gas_price, origin, config.eips.hardfork);
```

## Call Types

### Standard Call

Transfer value and execute code:

```zig
const params = CallParams{ .call = .{
  .caller = sender,
  .to = contract,
  .value = 1_000_000_000_000_000_000, // 1 ETH
  .input = calldata,
  .gas = 100_000,
} };
const result = evm.call(params);
```

### Static Call

Read-only execution (no state changes):

```zig
const params = CallParams{ .staticcall = .{
  .caller = sender,
  .to = contract,
  .input = calldata,
  .gas = 50_000,
} };
const result = evm.call(params);
```

### Delegate Call

Execute in caller's context:

```zig
const params = CallParams{ .delegatecall = .{
  .caller = sender,
  .to = implementation,
  .input = calldata,
  .gas = 100_000,
} };
const result = evm.call(params);
```

## Return Values

### Success/Failure

```zig
if (result.success) {
  if (result.output.len >= 32) {
    const v = std.mem.readInt(u256, result.output[0..32], .big);
  }
} else {
  // result.error_info may contain a short diagnostic string
}
```

### Gas Information

```zig
// Initial gas is from params.getGas(); remaining is in result.gas_left
const initial = params.getGas();
const used = if (result.gas_left <= initial) initial - result.gas_left else 0;
```

## State Access

Interact with state through the Database instance you passed into `Evm.init`:

```zig
// Account
const maybe = try db.get_account(address.bytes);
const balance = try db.get_balance(address.bytes);

// Storage
const slot = try db.get_storage(contract.bytes, key);

// Code
const code = try db.get_code_by_address(contract.bytes);
```

### Modifying State

```zig
// Transfer ETH
try evm.transfer(from, to, amount);

// Update storage
try evm.setStorage(contract, key, value);

// Self-destruct (careful!)
try evm.selfDestruct(contract, beneficiary);
```

## Execution Flow

::::steps
### Initialize

```zig
var evm = try Evm.init(allocator);
defer evm.deinit();
```

### Configure

```zig
evm.setTransactionContext(context);
evm.setDatabase(database);
```

### Execute

```zig
const result = try evm.execute(bytecode);
```

### Process Result

```zig
switch (result) {
    .success => handleSuccess(),
    .revert => handleRevert(),
}
```
::::

## Common Patterns

### Function Calls

Call a contract function with ABI encoding:

```zig
fn callFunction(
    evm: *Evm,
    contract: Address,
    selector: [4]u8,
    args: []const u8,
) ![]u8 {
    var calldata = std.ArrayList(u8).init(allocator);
    try calldata.appendSlice(&selector);
    try calldata.appendSlice(args);
    
    const result = try evm.call(.{
        .caller = sender,
        .target = contract,
        .data = calldata.items,
        .gas = 100_000,
        .value = 0,
        .is_static = false,
    });
    
    return switch (result) {
        .success => |data| data,
        .revert => error.CallReverted,
    };
}
```

### Event Monitoring

Track events during execution:

```zig
// Enable tracing
const TracedEvm = Evm(.{ .TracerType = EventTracer });

// Execute with tracing
const result = try evm.execute(bytecode);

// Get emitted events
const events = evm.tracer.getEvents();
for (events) |event| {
    std.debug.print("Event: {x}\n", .{event.topics[0]});
}
```

### Gas Estimation

Estimate gas for a transaction:

```zig
fn estimateGas(evm: *Evm, params: CallParams) !u64 {
    // Binary search for optimal gas
    var low: u64 = 21_000;
    var high: u64 = 10_000_000;
    
    while (low < high) {
        const mid = (low + high) / 2;
        params.gas = mid;
        
        const result = evm.call(params) catch {
            low = mid + 1;
            continue;
        };
        
        switch (result) {
            .success => high = mid,
            .revert => low = mid + 1,
        }
    }
    
    return low;
}
```

## Best Practices

:::tip[Execution Tips]
1. **Always set gas limits** - Prevent infinite loops
2. **Check return values** - Handle both success and revert
3. **Validate inputs** - Ensure bytecode is valid
4. **Use static calls for queries** - Prevent accidental state changes
5. **Track gas consumption** - Monitor efficiency
:::

## Error Scenarios

```zig
const result = evm.execute(bytecode) catch |err| {
    switch (err) {
        error.OutOfGas => {
            // Increase gas limit
        },
        error.InvalidJump => {
            // Bytecode has invalid JUMP
        },
        error.StackUnderflow => {
            // Stack operation failed
        },
        error.StaticCallViolation => {
            // Attempted state change in static call
        },
        else => return err,
    }
};
```

## Next Steps

- **[Configuration](/usage/configuration)** - Customize execution environment
- **[Error Handling](/usage/error-handling)** - Robust error management
- **[API Reference](/api/evm)** - Complete API documentation
- **[Advanced Execution](/advanced/architecture/evm-core)** - Deep dive into internals
