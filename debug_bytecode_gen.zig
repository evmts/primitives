const std = @import("std");
const common = @import("test/evm/opcodes/common.zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    
    const bytecode = try common.build_bytecode(allocator, 0x1b);
    defer allocator.free(bytecode);
    
    std.debug.print("Generated bytecode for SHL (0x1b):\n", .{});
    std.debug.print("Length: {}\n", .{bytecode.len});
    std.debug.print("Bytes: ", .{});
    for (bytecode) |b| {
        std.debug.print("{x:0>2} ", .{b});
    }
    std.debug.print("\n", .{});
    
    // Decode the bytecode manually to see what it does
    std.debug.print("\nDecoded bytecode:\n", .{});
    var i: usize = 0;
    while (i < bytecode.len) {
        const opcode = bytecode[i];
        switch (opcode) {
            0x60 => {
                if (i + 1 < bytecode.len) {
                    std.debug.print("PUSH1 0x{x:0>2}\n", .{bytecode[i + 1]});
                    i += 2;
                } else {
                    std.debug.print("Invalid PUSH1\n", .{});
                    break;
                }
            },
            0x1b => {
                std.debug.print("SHL\n", .{});
                i += 1;
            },
            0x52 => {
                std.debug.print("MSTORE\n", .{});
                i += 1;
            },
            0xf3 => {
                std.debug.print("RETURN\n", .{});
                i += 1;
            },
            else => {
                std.debug.print("Unknown opcode: 0x{x:0>2}\n", .{opcode});
                i += 1;
            }
        }
    }
}