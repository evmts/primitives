# Ethereum Primitives & Cryptography for Zig

Zig 0.15.1+ | https://github.com/evmts/primitives | Mission-critical crypto infrastructure - zero error tolerance

---

## Critical Context

<zig_version_breaking_changes>
**Zig 0.15.1 ArrayList API (LLMs get this wrong):**
```zig
// ✅ CORRECT - UNMANAGED, allocator required every call
var list = std.ArrayList(T){};
defer list.deinit(allocator);
try list.append(allocator, item);

// ❌ WRONG - old API
var list = std.ArrayList(T).init(allocator);  // No init() method!
list.deinit();  // Missing allocator
```
</zig_version_breaking_changes>

---

## Library Scope

<modules>
**primitives:** Uint256, Address, Hex, RLP, ABI, Transactions (Legacy, EIP-1559, EIP-2930, EIP-4844, EIP-7702), Event Logs, Access Lists, Bytecode, Opcodes, Hardforks, Merkle Patricia Trie

**crypto:** Keccak-256, secp256k1 ECDSA (⚠️ unaudited), EIP-712 (⚠️ unaudited), BLS12-381 (via BLST), BN254 alt_bn128 (⚠️ unaudited), KZG (via c-kzg-4844), SHA256, RIPEMD160 (⚠️ unaudited), Blake2 (⚠️ unaudited), ModExp (⚠️ unaudited)

**precompiles:** All Ethereum precompiles (0x01-0x13)

External C libs: blst, c-kzg-4844, arkworks (Rust, no WASM)
</modules>

<usage>
**Import modules:**
```zig
const primitives = @import("primitives");
const crypto = @import("crypto");
```

**Add to build.zig.zon:**
```zig
.dependencies = .{
    .primitives = .{
        .url = "https://github.com/evmts/primitives/archive/<commit>.tar.gz",
        .hash = "<hash>",
    },
},
```

**Add to build.zig:**
```zig
const primitives = b.dependency("primitives", .{
    .target = target,
    .optimize = optimize,
});
exe.root_module.addImport("primitives", primitives.module("primitives"));
exe.root_module.addImport("crypto", primitives.module("crypto"));
```
</usage>

---

## API Quick Reference

### Address

```zig
const addr = try Address.fromHex("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const addr_u256 = Address.fromU256(some_u256);
const addr_bytes = try Address.fromBytes(&bytes_20);
const addr_pubkey = Address.fromPublicKey(public_key_x, public_key_y);

const as_u256 = addr.toU256();
const hex = addr.toHex();  // [42]u8
const checksummed = addr.toChecksumHex();  // EIP-55

const is_valid = Address.isValid(hex_string);
const is_checksum_valid = Address.isValidChecksum(hex_string);
const zero_addr = Address.zero();

// Contract addresses
const create_addr = try Address.calculateCreateAddress(allocator, deployer, nonce);
const create2_addr = try Address.calculateCreate2Address(allocator, deployer, salt, init_code);
```

### Hex

```zig
const valid = Hex.isHex("0x1234abcd");  // Requires 0x prefix

const bytes = try Hex.hexToBytes(allocator, "0x1234");
defer allocator.free(bytes);

const hex = try Hex.bytesToHex(allocator, &bytes);
defer allocator.free(hex);

const value = try Hex.hexToU256("0xdeadbeef");
const hex_str = try Hex.u256ToHex(allocator, value);
defer allocator.free(hex_str);

const padded = try Hex.padLeft(allocator, &bytes, 32);
defer allocator.free(padded);

const trimmed = Hex.trimLeftZeros(&bytes);  // No alloc
```

### RLP

```zig
const encoded = try Rlp.encode(allocator, value);
defer allocator.free(encoded);

const decoded = try Rlp.decode(allocator, encoded, false);
defer decoded.data.deinit(allocator);

switch (decoded.data) {
    .String => |str| { /* bytes */ },
    .List => |items| { /* nested items */ },
}

// Stream mode for multiple items
const item = try Rlp.decode(allocator, data, true);  // Stream=true
remaining = item.remainder;
```

### ABI

```zig
const selector = abi.computeSelector("transfer(address,uint256)");

const params = [_]abi.AbiValue{
    abi.addressValue(recipient),
    abi.uint256_value(amount),
};

const calldata = try abi.encodeFunctionData(allocator, selector, &params);
defer allocator.free(calldata);

const types = [_]abi.AbiType{ .address, .uint256 };
const result = try abi.decodeFunctionData(allocator, calldata, &types);
defer {
    for (result.parameters) |param| {
        switch (param) {
            .string, .bytes => |slice| allocator.free(slice),
            else => {},
        }
    }
    allocator.free(result.parameters);
}

const packed = try abi.encodePacked(allocator, &values);  // No padding
defer allocator.free(packed);
```

### Keccak-256

```zig
const hash = HashUtils.keccak256("hello");
const hash_hex = try HashUtils.fromHex("0x1234...");

const hex_lower = HashUtils.toHex(hash);  // [66]u8
const message_hash = try HashUtils.eip191HashMessage("Sign this", allocator);

const are_equal = HashUtils.equal(hash1, hash2);  // Constant-time
const selector = HashUtils.selectorFromSignature("transfer(address,uint256)");
```

### secp256k1 (⚠️ UNAUDITED)

```zig
const private_key = try Crypto.unaudited_randomPrivateKey();
const public_key = try Crypto.unaudited_getPublicKey(private_key);
const address = Crypto.publicKeyToAddress(public_key);

const signature = try Crypto.unaudited_signMessage("Hello", private_key);
const hash_sig = try Crypto.unaudited_signHash(hash, private_key);

const is_valid = try Crypto.unaudited_verifyMessage(message, signature, address);
const recovered = try Crypto.unaudited_recoverAddress(hash, signature);

const sig_valid = signature.isValid();  // Validates r, s, v
const sig_bytes = signature.toBytes();  // [65]u8
```

### Transactions

```zig
const tx = LegacyTransaction{
    .nonce = 0,
    .gas_price = 20_000_000_000,  // 20 gwei
    .gas_limit = 21000,
    .to = recipient,
    .value = 1_000_000_000_000_000_000,  // 1 ETH
    .data = &[_]u8{},
    .v = 0, .r = [_]u8{0} ** 32, .s = [_]u8{0} ** 32,
};

const encoded = try Transaction.encodeLegacyForSigning(allocator, tx, chain_id);
defer allocator.free(encoded);

const signed = try Transaction.signLegacyTransaction(allocator, tx, private_key, chain_id);
const hash = try Transaction.computeLegacyTransactionHash(allocator, signed);
const tx_type = Transaction.detectTransactionType(raw_data);

// EIP-1559
const eip1559 = Eip1559Transaction{
    .chain_id = 1,
    .nonce = 0,
    .max_priority_fee_per_gas = 2_000_000_000,  // 2 gwei tip
    .max_fee_per_gas = 30_000_000_000,  // 30 gwei max
    .gas_limit = 21000,
    .to = recipient,
    .value = amount,
    .data = &[_]u8{},
    .access_list = &[_]AccessListItem{},
    .v = 0, .r = [_]u8{0} ** 32, .s = [_]u8{0} ** 32,
};
```

### EIP-712 (⚠️ UNAUDITED)

```zig
const domain = try Eip712.create_domain(allocator, "MyDApp", "1.0.0", 1, null);
defer {
    var mut_domain = domain;
    mut_domain.deinit(allocator);
}

var typed_data = try Eip712.create_simple_typed_data(allocator, domain, "Transfer");
defer typed_data.deinit(allocator);

const props = [_]Eip712.TypeProperty{
    .{ .name = "from", .type = "address" },
    .{ .name = "to", .type = "address" },
    .{ .name = "amount", .type = "uint256" },
};
try typed_data.types.put(allocator, "Transfer", &props);

const hash = try Eip712.unaudited_hashTypedData(allocator, &typed_data);
const signature = try Eip712.unaudited_signTypedData(allocator, &typed_data, private_key);
const recovered = try Eip712.unaudited_recoverTypedDataAddress(allocator, &typed_data, signature);
```

---

## Memory Patterns

```zig
// Same scope: defer allocator.destroy(thing);
// Ownership transfer: errdefer allocator.destroy(thing);
// GPA setup:
var gpa = std.heap.GeneralPurposeAllocator(.{}){};
defer _ = gpa.deinit();
const allocator = gpa.allocator();
```

---

## Security Requirements

<crypto_safety>
**Constant-time ops required. All crypto must:**
- Validate inputs (sig components, curve points)
- Never panic (return errors)
- Clear sensitive memory
- No timing leaks (no early returns in comparisons)

```zig
// ✅ Constant-time compare
var result: u8 = 0;
for (a, b) |byte_a, byte_b| { result |= byte_a ^ byte_b; }
return result == 0;
// ❌ if (byte_a != byte_b) return false;  // Leaks timing
```
</crypto_safety>

<unaudited_functions>
**Unaudited (DO NOT use in prod):** All `unaudited_*` functions, all `Eip712.unaudited_*`, RIPEMD160, Blake2, ModExp, pure Zig BN254
**Audited libs:** BLS12-381 (BLST), KZG (c-kzg-4844), BN254 (Arkworks), SHA256
</unaudited_functions>

---

## Documentation

<docs_base_url>
Base: https://github.com/evmts/primitives/blob/main/docs
</docs_base_url>

<main_docs>
- [Documentation Overview](https://github.com/evmts/primitives/blob/main/docs/DOCUMENTATION.md)
- [README](https://github.com/evmts/primitives/blob/main/docs/README.md)
</main_docs>

<crypto_docs>
**Cryptography:**
- [Crypto Module](https://github.com/evmts/primitives/blob/main/docs/crypto/crypto.zig.md)
- [Hash Utils](https://github.com/evmts/primitives/blob/main/docs/crypto/hash.zig.md)
- [Hash Algorithms](https://github.com/evmts/primitives/blob/main/docs/crypto/hash_algorithms.zig.md)
- [secp256k1](https://github.com/evmts/primitives/blob/main/docs/crypto/secp256k1.zig.md)
</crypto_docs>

<primitives_docs>
**Primitives:**
- [Event Logs](https://github.com/evmts/primitives/blob/main/docs/primitives/logs.md)
- [Hardforks](https://github.com/evmts/primitives/blob/main/docs/primitives/hardfork.md)
- [Sign-In with Ethereum (SIWE)](https://github.com/evmts/primitives/blob/main/docs/primitives/siwe.md)
</primitives_docs>

<precompiles_docs>
**Precompiles:**
- [Overview](https://github.com/evmts/primitives/blob/main/docs/precompiles/README.md)
- [Common Types](https://github.com/evmts/primitives/blob/main/docs/precompiles/common.md)
- [Utils](https://github.com/evmts/primitives/blob/main/docs/precompiles/utils.md)
- [SHA256 (0x02)](https://github.com/evmts/primitives/blob/main/docs/precompiles/sha256.md)
- [RIPEMD160 (0x03)](https://github.com/evmts/primitives/blob/main/docs/precompiles/ripemd160.md)
- [Identity (0x04)](https://github.com/evmts/primitives/blob/main/docs/precompiles/identity.md)
- [ModExp (0x05)](https://github.com/evmts/primitives/blob/main/docs/precompiles/modexp.md)
- [BN254 Add (0x06)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bn254_add.md)
- [BN254 Mul (0x07)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bn254_mul.md)
- [BN254 Pairing (0x08)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bn254_pairing.md)
- [Blake2F (0x09)](https://github.com/evmts/primitives/blob/main/docs/precompiles/blake2f.md)
- [Point Evaluation (0x0a)](https://github.com/evmts/primitives/blob/main/docs/precompiles/point_evaluation.md)
- [BLS12-381 G1 Add (0x0b)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bls12_g1_add.md)
- [BLS12-381 G1 Mul (0x0c)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bls12_g1_mul.md)
- [BLS12-381 G1 MSM (0x0d)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bls12_g1_msm.md)
- [BLS12-381 G2 Add (0x0e)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bls12_g2_add.md)
- [BLS12-381 G2 Mul (0x0f)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bls12_g2_mul.md)
- [BLS12-381 G2 MSM (0x10)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bls12_g2_msm.md)
- [BLS12-381 Pairing (0x11)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bls12_pairing.md)
- [BLS12-381 Map Fp to G1 (0x12)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bls12_map_fp_to_g1.md)
- [BLS12-381 Map Fp2 to G2 (0x13)](https://github.com/evmts/primitives/blob/main/docs/precompiles/bls12_map_fp2_to_g2.md)
</precompiles_docs>

<external_resources>
**External Resources:**
- [Zig 0.15.1 Docs](https://ziglang.org/documentation/0.15.1/)
- [Ethereum EIPs](https://eips.ethereum.org/)
- [Repository](https://github.com/evmts/primitives)
</external_resources>
