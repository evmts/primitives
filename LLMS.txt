# Ethereum Primitives & Cryptography for Zig

**Version:** Zig 0.15.1+ | **Repo:** https://github.com/evmts/primitives

Mission-critical cryptographic infrastructure. Zero error tolerance.

---

## Critical Context

<zig_version_breaking_changes>
**Zig 0.15.1 ArrayList API Change (LLMs commonly get this wrong):**

```zig
// ✅ CORRECT - 0.15.1 uses UNMANAGED ArrayList
var list = std.ArrayList(T){};  // Default init
defer list.deinit(allocator);   // allocator REQUIRED
try list.append(allocator, item); // allocator REQUIRED every call

// ❌ WRONG - Old API (pre-0.15)
var list = std.ArrayList(T).init(allocator);  // No init() method!
list.deinit();  // Missing required allocator param
```

All ArrayList operations require explicit allocator parameter in 0.15.1+
</zig_version_breaking_changes>

<build_requirements>
**Always run from repo root. Every code change requires:**
```bash
zig build && zig build test
```
Exception: `.md` files only

Use `zig build test` not `zig test` (requires module system)
</build_requirements>

<banned_patterns>
- ❌ Stub implementations (`error.NotImplemented`)
- ❌ Swallowing errors (`catch {}`, `catch null`, `catch &.{}`)
- ❌ `std.debug.print` in library code
- ❌ `std.debug.assert` (use proper error handling)
- ❌ Commented tests or code
- ❌ Placeholder implementations

Cryptographic ops must NEVER crash - return errors gracefully
</banned_patterns>

---

## Library Scope

<modules>
**primitives:** Uint256, Address, Hex, RLP, ABI, Transactions (Legacy, EIP-1559, EIP-2930, EIP-4844, EIP-7702), Event Logs, Access Lists, Bytecode, Opcodes, Hardforks, Merkle Patricia Trie

**crypto:** Keccak-256, secp256k1 ECDSA (⚠️ unaudited), EIP-712 (⚠️ unaudited), BLS12-381 (via BLST), BN254 alt_bn128 (⚠️ unaudited), KZG (via c-kzg-4844), SHA256, RIPEMD160 (⚠️ unaudited), Blake2 (⚠️ unaudited), ModExp (⚠️ unaudited)

**precompiles:** All Ethereum precompiles (0x01-0x13)

External C libs: blst, c-kzg-4844, arkworks (Rust, no WASM)
</modules>

<imports>
```zig
const primitives = @import("primitives");
const crypto = @import("crypto");
const Address = primitives.Address;
```
Never use parent imports (`@import("../primitives/address.zig")`)
</imports>

---

## API Quick Reference

### Address

```zig
const addr = try Address.fromHex("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const addr_u256 = Address.fromU256(some_u256);
const addr_bytes = try Address.fromBytes(&bytes_20);
const addr_pubkey = Address.fromPublicKey(public_key_x, public_key_y);

const as_u256 = addr.toU256();
const hex = addr.toHex();  // [42]u8
const checksummed = addr.toChecksumHex();  // EIP-55

const is_valid = Address.isValid(hex_string);
const is_checksum_valid = Address.isValidChecksum(hex_string);
const zero_addr = Address.zero();

// Contract addresses
const create_addr = try Address.calculateCreateAddress(allocator, deployer, nonce);
const create2_addr = try Address.calculateCreate2Address(allocator, deployer, salt, init_code);
```

### Hex

```zig
const valid = Hex.isHex("0x1234abcd");  // Requires 0x prefix

const bytes = try Hex.hexToBytes(allocator, "0x1234");
defer allocator.free(bytes);

const hex = try Hex.bytesToHex(allocator, &bytes);
defer allocator.free(hex);

const value = try Hex.hexToU256("0xdeadbeef");
const hex_str = try Hex.u256ToHex(allocator, value);
defer allocator.free(hex_str);

const padded = try Hex.padLeft(allocator, &bytes, 32);
defer allocator.free(padded);

const trimmed = Hex.trimLeftZeros(&bytes);  // No alloc
```

### RLP

```zig
const encoded = try Rlp.encode(allocator, value);
defer allocator.free(encoded);

const decoded = try Rlp.decode(allocator, encoded, false);
defer decoded.data.deinit(allocator);

switch (decoded.data) {
    .String => |str| { /* bytes */ },
    .List => |items| { /* nested items */ },
}

// Stream mode for multiple items
const item = try Rlp.decode(allocator, data, true);  // Stream=true
remaining = item.remainder;
```

### ABI

```zig
const selector = abi.computeSelector("transfer(address,uint256)");

const params = [_]abi.AbiValue{
    abi.addressValue(recipient),
    abi.uint256_value(amount),
};

const calldata = try abi.encodeFunctionData(allocator, selector, &params);
defer allocator.free(calldata);

const types = [_]abi.AbiType{ .address, .uint256 };
const result = try abi.decodeFunctionData(allocator, calldata, &types);
defer {
    for (result.parameters) |param| {
        switch (param) {
            .string, .bytes => |slice| allocator.free(slice),
            else => {},
        }
    }
    allocator.free(result.parameters);
}

const packed = try abi.encodePacked(allocator, &values);  // No padding
defer allocator.free(packed);
```

### Keccak-256

```zig
const hash = HashUtils.keccak256("hello");
const hash_hex = try HashUtils.fromHex("0x1234...");

const hex_lower = HashUtils.toHex(hash);  // [66]u8
const message_hash = try HashUtils.eip191HashMessage("Sign this", allocator);

const are_equal = HashUtils.equal(hash1, hash2);  // Constant-time
const selector = HashUtils.selectorFromSignature("transfer(address,uint256)");
```

### secp256k1 (⚠️ UNAUDITED)

```zig
const private_key = try Crypto.unaudited_randomPrivateKey();
const public_key = try Crypto.unaudited_getPublicKey(private_key);
const address = Crypto.publicKeyToAddress(public_key);

const signature = try Crypto.unaudited_signMessage("Hello", private_key);
const hash_sig = try Crypto.unaudited_signHash(hash, private_key);

const is_valid = try Crypto.unaudited_verifyMessage(message, signature, address);
const recovered = try Crypto.unaudited_recoverAddress(hash, signature);

const sig_valid = signature.isValid();  // Validates r, s, v
const sig_bytes = signature.toBytes();  // [65]u8
```

### Transactions

```zig
const tx = LegacyTransaction{
    .nonce = 0,
    .gas_price = 20_000_000_000,  // 20 gwei
    .gas_limit = 21000,
    .to = recipient,
    .value = 1_000_000_000_000_000_000,  // 1 ETH
    .data = &[_]u8{},
    .v = 0, .r = [_]u8{0} ** 32, .s = [_]u8{0} ** 32,
};

const encoded = try Transaction.encodeLegacyForSigning(allocator, tx, chain_id);
defer allocator.free(encoded);

const signed = try Transaction.signLegacyTransaction(allocator, tx, private_key, chain_id);
const hash = try Transaction.computeLegacyTransactionHash(allocator, signed);
const tx_type = Transaction.detectTransactionType(raw_data);

// EIP-1559
const eip1559 = Eip1559Transaction{
    .chain_id = 1,
    .nonce = 0,
    .max_priority_fee_per_gas = 2_000_000_000,  // 2 gwei tip
    .max_fee_per_gas = 30_000_000_000,  // 30 gwei max
    .gas_limit = 21000,
    .to = recipient,
    .value = amount,
    .data = &[_]u8{},
    .access_list = &[_]AccessListItem{},
    .v = 0, .r = [_]u8{0} ** 32, .s = [_]u8{0} ** 32,
};
```

### EIP-712 (⚠️ UNAUDITED)

```zig
const domain = try Eip712.create_domain(allocator, "MyDApp", "1.0.0", 1, null);
defer {
    var mut_domain = domain;
    mut_domain.deinit(allocator);
}

var typed_data = try Eip712.create_simple_typed_data(allocator, domain, "Transfer");
defer typed_data.deinit(allocator);

const props = [_]Eip712.TypeProperty{
    .{ .name = "from", .type = "address" },
    .{ .name = "to", .type = "address" },
    .{ .name = "amount", .type = "uint256" },
};
try typed_data.types.put(allocator, "Transfer", &props);

const hash = try Eip712.unaudited_hashTypedData(allocator, &typed_data);
const signature = try Eip712.unaudited_signTypedData(allocator, &typed_data, private_key);
const recovered = try Eip712.unaudited_recoverTypedDataAddress(allocator, &typed_data, signature);
```

---

## Memory Patterns

```zig
// Same scope cleanup
const thing = try allocator.create(Thing);
defer allocator.destroy(thing);

// Ownership transfer
const thing = try allocator.create(Thing);
errdefer allocator.destroy(thing);
thing.* = try Thing.init(allocator);
return thing;

// Common GPA setup
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
}
```

---

## Security Requirements

<crypto_safety>
**Constant-time operations required:**
```zig
// ✅ CORRECT
pub fn constant_time_compare(a: []const u8, b: []const u8) bool {
    if (a.len != b.len) return false;
    var result: u8 = 0;
    for (a, b) |byte_a, byte_b| {
        result |= byte_a ^ byte_b;
    }
    return result == 0;
}

// ❌ WRONG - timing leak
if (byte_a != byte_b) return false;  // Early return leaks position
```

**All crypto functions must:**
- Validate inputs (signature components, curve points)
- Never panic/crash (return errors)
- Clear sensitive memory
- Avoid timing attacks
</crypto_safety>

<unaudited_functions>
**DO NOT use in production without audit:**
- `unaudited_randomPrivateKey()`, `unaudited_getPublicKey()`
- `unaudited_signMessage()`, `unaudited_signHash()`
- `unaudited_verifyMessage()`, `unaudited_recoverAddress()`
- All `Eip712.unaudited_*` functions
- `unaudited_mulmod()`, `unaudited_invmod()` (timing attacks)
- RIPEMD160, Blake2, ModExp, pure Zig BN254

**Audited via external libs:**
- BLS12-381 (BLST), KZG (c-kzg-4844), BN254 via Arkworks, SHA256
</unaudited_functions>

---

## Testing Notes

<test_behavior>
**Zig test output:** No output = tests PASSED ✅

Only failed tests produce output. This is normal behavior.

```zig
test "example" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Test body - self-contained, no helpers
    const result = try someFunction(allocator);
    defer allocator.free(result);

    try std.testing.expectEqual(expected, result);
}
```

Debug logging (still won't show if test passes):
```zig
std.testing.log_level = .debug;
std.log.debug("Value: {}", .{value});
```
</test_behavior>

---

## Resources

- **Zig Docs:** https://ziglang.org/documentation/0.15.1/
- **Ethereum Specs:** https://eips.ethereum.org/
- **Repo:** https://github.com/evmts/primitives

**Full documentation in `/docs` directory for detailed examples and guides.**
