const std = @import("std");
const DifferentialTestor = @import("differential_testor.zig").DifferentialTestor;
const testing = std.testing;

test "differential: GT opcode - ERC20 deployment bug case" {
    // This is the exact case that fails in ERC20 deployment
    // GT(0xd, 0xffffffffffffffff) should return 0 (false)
    const allocator = testing.allocator;
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();

    // Test the exact values from the ERC20 deployment trace
    const bytecode = [_]u8{
        // Push 0xffffffffffffffff (max uint64)
        0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        // Push 0xd (13 - string length)
        0x60, 0x0d,
        // GT: is 0xd > 0xffffffffffffffff?
        0x11,
        // The result should be 0 (false)
    };

    try testor.test_bytecode(&bytecode);
}

test "differential: comparison opcodes comprehensive" {
    const allocator = testing.allocator;
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();

    // Test all comparison opcodes with edge cases
    const bytecode = [_]u8{
        // Test 1: LT with small numbers
        0x60, 0x05,  // PUSH1 5
        0x60, 0x0a,  // PUSH1 10
        0x10,        // LT (5 < 10 = 1)
        
        // Test 2: GT with small numbers
        0x60, 0x05,  // PUSH1 5
        0x60, 0x0a,  // PUSH1 10
        0x11,        // GT (10 > 5 = 1)
        
        // Test 3: LT with max values
        0x60, 0x00,  // PUSH1 0
        0x7f,        // PUSH32 MAX_U256
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x10,        // LT (MAX < 0 = 0)
        
        // Test 4: GT with max values  
        0x7f,        // PUSH32 MAX_U256
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x60, 0x00,  // PUSH1 0
        0x11,        // GT (0 > MAX = 0)
        
        // Test 5: EQ with same values
        0x60, 0x42,  // PUSH1 0x42
        0x60, 0x42,  // PUSH1 0x42
        0x14,        // EQ (0x42 == 0x42 = 1)
        
        // Test 6: ISZERO with zero
        0x60, 0x00,  // PUSH1 0
        0x15,        // ISZERO (0 == 0 = 1)
        
        // Test 7: ISZERO with non-zero
        0x60, 0x01,  // PUSH1 1
        0x15,        // ISZERO (1 == 0 = 0)
    };

    try testor.test_bytecode(&bytecode);
}

test "differential: GT opcode edge cases" {
    const allocator = testing.allocator;
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();

    // Test various edge cases for GT opcode
    const bytecode = [_]u8{
        // Test 1: 0 > 0 = 0
        0x60, 0x00,  // PUSH1 0
        0x60, 0x00,  // PUSH1 0
        0x11,        // GT
        
        // Test 2: 1 > 0 = 1
        0x60, 0x00,  // PUSH1 0
        0x60, 0x01,  // PUSH1 1
        0x11,        // GT
        
        // Test 3: 0 > 1 = 0
        0x60, 0x01,  // PUSH1 1
        0x60, 0x00,  // PUSH1 0
        0x11,        // GT
        
        // Test 4: MAX_U256 > MAX_U256 = 0
        0x7f,        // PUSH32 MAX_U256
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x7f,        // PUSH32 MAX_U256
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x11,        // GT
        
        // Test 5: MAX_U256 > (MAX_U256 - 1) = 1
        0x7f,        // PUSH32 MAX_U256 - 1
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
        0x7f,        // PUSH32 MAX_U256
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x11,        // GT
        
        // Test 6: 0xffffffffffffffff > 0xd = 1
        0x60, 0x0d,  // PUSH1 0xd (13)
        0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // PUSH8 max uint64
        0x11,        // GT
        
        // Test 7: 0xd > 0xffffffffffffffff = 0 (THE BUG CASE)
        0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // PUSH8 max uint64
        0x60, 0x0d,  // PUSH1 0xd (13)
        0x11,        // GT
    };

    try testor.test_bytecode(&bytecode);
}

test "differential: LT opcode edge cases" {
    const allocator = testing.allocator;
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();

    // Test various edge cases for LT opcode
    const bytecode = [_]u8{
        // Test 1: 0 < 0 = 0
        0x60, 0x00,  // PUSH1 0
        0x60, 0x00,  // PUSH1 0
        0x10,        // LT
        
        // Test 2: 0 < 1 = 1
        0x60, 0x01,  // PUSH1 1
        0x60, 0x00,  // PUSH1 0
        0x10,        // LT
        
        // Test 3: 1 < 0 = 0
        0x60, 0x00,  // PUSH1 0
        0x60, 0x01,  // PUSH1 1
        0x10,        // LT
        
        // Test 4: 0xd < 0xffffffffffffffff = 1
        0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // PUSH8 max uint64
        0x60, 0x0d,  // PUSH1 0xd (13)
        0x10,        // LT
        
        // Test 5: 0xffffffffffffffff < 0xd = 0
        0x60, 0x0d,  // PUSH1 0xd (13)
        0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // PUSH8 max uint64
        0x10,        // LT
    };

    try testor.test_bytecode(&bytecode);
}

test "differential: signed comparison opcodes" {
    const allocator = testing.allocator;
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();

    // Test SLT and SGT with signed values
    const bytecode = [_]u8{
        // Test 1: SLT with -1 < 1 = 1
        0x60, 0x01,  // PUSH1 1
        0x7f,        // PUSH32 -1 (all bits set)
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x12,        // SLT
        
        // Test 2: SGT with 1 > -1 = 1
        0x7f,        // PUSH32 -1 (all bits set)
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x60, 0x01,  // PUSH1 1
        0x13,        // SGT
        
        // Test 3: SLT with 0 < -1 = 0 (unsigned: 0 < MAX = 1, but signed: 0 < -1 = 0)
        0x7f,        // PUSH32 -1 (all bits set)
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x60, 0x00,  // PUSH1 0
        0x12,        // SLT
        
        // Test 4: SGT with -1 > 0 = 0
        0x60, 0x00,  // PUSH1 0
        0x7f,        // PUSH32 -1 (all bits set)
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x13,        // SGT
    };

    try testor.test_bytecode(&bytecode);
}