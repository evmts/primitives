const std = @import("std");
const DifferentialTestor = @import("differential_testor.zig").DifferentialTestor;

const testing = std.testing;

test "differential: basic arithmetic operations" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Bytecode that performs various arithmetic operations and returns the result
    // Operations: 
    // 1. ADD: 5 + 3 = 8
    // 2. SUB: 10 - 4 = 6  
    // 3. MUL: 8 * 6 = 48 (0x30)
    // 4. DIV: 48 / 2 = 24 (0x18)
    // 5. MOD: 24 % 7 = 3
    // 6. ADDMOD: (3 + 5) % 5 = 3
    // 7. MULMOD: (3 * 4) % 5 = 2
    // 8. EXP: 2 ^ 3 = 8
    // 9. Final ADD: 8 + 1 = 9
    // Return 9 as 32-byte word
    
    const bytecode = [_]u8{
        // 1. ADD: 5 + 3
        0x60, 0x05, // PUSH1 5
        0x60, 0x03, // PUSH1 3
        0x01,       // ADD (result: 8)
        
        // 2. SUB: 10 - 4
        0x60, 0x0a, // PUSH1 10
        0x60, 0x04, // PUSH1 4
        0x03,       // SUB (result: 6)
        
        // 3. MUL: 8 * 6
        0x02,       // MUL (result: 48)
        
        // 4. DIV: 48 / 2
        0x60, 0x02, // PUSH1 2
        0x04,       // DIV (result: 24)
        
        // 5. MOD: 24 % 7
        0x60, 0x07, // PUSH1 7
        0x06,       // MOD (result: 3)
        
        // 6. ADDMOD: (3 + 5) % 5
        0x60, 0x05, // PUSH1 5
        0x60, 0x05, // PUSH1 5
        0x08,       // ADDMOD (result: 3)
        
        // 7. MULMOD: (3 * 4) % 5
        0x60, 0x04, // PUSH1 4
        0x60, 0x05, // PUSH1 5
        0x09,       // MULMOD (result: 2)
        
        // 8. EXP: 2 ^ 3
        0x60, 0x03, // PUSH1 3
        0x0a,       // EXP (result: 8)
        
        // 9. Final ADD: 8 + 1
        0x60, 0x01, // PUSH1 1
        0x01,       // ADD (result: 9)
        
        // Store result in memory and return
        0x60, 0x00, // PUSH1 0 (memory offset)
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32 (return size)
        0x60, 0x00, // PUSH1 0 (return offset)
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}

test "differential: signed arithmetic operations" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Test SDIV, SMOD, and SIGNEXTEND
    const bytecode = [_]u8{
        // SDIV: -8 / 3 = -2 (in two's complement)
        0x7f, // PUSH32
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // bytes 1-8 of data
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // bytes 9-16 of data
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // bytes 17-24 of data
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,  // bytes 25-32 of data (-8 in two's complement)
        0x60, 0x03, // PUSH1 3
        0x05,       // SDIV (result: -2)
        
        // Convert to positive for easier testing: -(-2) = 2
        0x60, 0x00, // PUSH1 0
        0x03,       // SUB (0 - (-2) = 2)
        
        // Store and return
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}

test "differential: comparison operations" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Test LT, GT, EQ, ISZERO
    const bytecode = [_]u8{
        // LT: 5 < 10 = 1
        0x60, 0x05, // PUSH1 5
        0x60, 0x0a, // PUSH1 10
        0x10,       // LT (result: 1)
        
        // GT: 10 > 5 = 1
        0x60, 0x0a, // PUSH1 10
        0x60, 0x05, // PUSH1 5
        0x11,       // GT (result: 1)
        
        // ADD: 1 + 1 = 2
        0x01,       // ADD
        
        // EQ: 2 == 2 = 1
        0x60, 0x02, // PUSH1 2
        0x14,       // EQ (result: 1)
        
        // ISZERO: !1 = 0, then !0 = 1
        0x15,       // ISZERO (result: 0)
        0x15,       // ISZERO (result: 1)
        
        // Store and return
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}

test "differential: division by zero" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Test DIV/MOD/SDIV/SMOD with zero divisor
    const bytecode = [_]u8{
        // DIV: 10 / 0 = 0
        0x60, 0x0a, // PUSH1 10
        0x60, 0x00, // PUSH1 0
        0x04,       // DIV (result: 0)
        
        // MOD: 10 % 0 = 0
        0x60, 0x0a, // PUSH1 10
        0x60, 0x00, // PUSH1 0
        0x06,       // MOD (result: 0)
        
        // SDIV: -10 / 0 = 0
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, // PUSH32 -10
        0x60, 0x00, // PUSH1 0
        0x05,       // SDIV (result: 0)
        
        // Add all results: 0 + 0 + 0 = 0
        0x01,       // ADD
        0x01,       // ADD
        
        // Store and return
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}

test "differential: max value arithmetic" {
    const allocator = testing.allocator;
    
    std.debug.print("\n\n===== STARTING MAX VALUE ARITHMETIC TEST =====\n", .{});
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Test arithmetic with max u256 values
    const bytecode = [_]u8{
        // MAX_U256 + 1 = 0 (overflow)
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x60, 0x01, // PUSH1 1
        0x01,       // ADD (result: 0)
        
        // 0 - 1 = MAX_U256 (underflow)
        0x60, 0x00, // PUSH1 0
        0x60, 0x01, // PUSH1 1
        0x03,       // SUB (result: MAX_U256)
        
        // MAX_U256 * 2 = MAX_U256 - 1 (overflow)
        0x60, 0x02, // PUSH1 2
        0x02,       // MUL
        
        // Store and return
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}

test "differential: modexp edge cases" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Test ADDMOD/MULMOD edge cases
    const bytecode = [_]u8{
        // ADDMOD: (MAX_U256 + MAX_U256) % 10 
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x60, 0x0a, // PUSH1 10
        0x08,       // ADDMOD
        
        // MULMOD: (MAX_U256 * MAX_U256) % 7
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x60, 0x07, // PUSH1 7
        0x09,       // MULMOD
        
        // Add results
        0x01,       // ADD
        
        // Store and return
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}

test "differential: simple PUSH32" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Single PUSH32 and STOP
    const bytecode = [_]u8{
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    std.debug.print("\n=== Testing simple PUSH32 ===\n", .{});
    std.debug.print("Bytecode length: {}\n", .{bytecode.len});
    
    try testor.test_bytecode(&bytecode);
}

test "differential: exp edge cases" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Test EXP with edge cases
    const bytecode = [_]u8{
        // 0^0 = 1
        0x60, 0x00, // PUSH1 0
        0x60, 0x00, // PUSH1 0
        0x0a,       // EXP (result: 1)
        
        // 0^N = 0 (N > 0)
        0x60, 0x00, // PUSH1 0
        0x60, 0x05, // PUSH1 5
        0x0a,       // EXP (result: 0)
        
        // N^0 = 1
        0x60, 0x0a, // PUSH1 10
        0x60, 0x00, // PUSH1 0
        0x0a,       // EXP (result: 1)
        
        // 2^255 (large exponent)
        0x60, 0x02, // PUSH1 2
        0x60, 0xff, // PUSH1 255
        0x0a,       // EXP
        
        // Add first three results
        0x01,       // ADD
        0x01,       // ADD
        0x01,       // ADD
        
        // Store and return
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}

test "differential: signed arithmetic edge cases" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // std.debug.print("\n[DEBUG] Starting signed arithmetic edge cases test\n", .{});
    
    // Test SDIV/SMOD with MIN_INT and -1
    const bytecode = [_]u8{
        // SDIV: MIN_INT / -1 = MIN_INT (overflow)
        0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PUSH32 MIN_INT256
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 -1
        0x05,       // SDIV
        
        // SMOD: MIN_INT % -1 = 0
        0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PUSH32 MIN_INT256
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 -1
        0x07,       // SMOD
        
        // Add results
        0x01,       // ADD
        
        // Store and return
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}

test "differential: comparison edge cases" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Test comparisons with edge values
    const bytecode = [_]u8{
        // LT: MAX_U256 < 0 = 0
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x60, 0x00, // PUSH1 0
        0x10,       // LT (result: 0)
        
        // GT: 0 > MAX_U256 = 0
        0x60, 0x00, // PUSH1 0
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x11,       // GT (result: 0)
        
        // SLT: -1 < 1 = 1
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 -1
        0x60, 0x01, // PUSH1 1
        0x12,       // SLT (result: 1)
        
        // SGT: 1 > -1 = 1
        0x60, 0x01, // PUSH1 1
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 -1
        0x13,       // SGT (result: 1)
        
        // Sum: 0 + 0 + 1 + 1 = 2
        0x01,       // ADD
        0x01,       // ADD
        0x01,       // ADD
        
        // Store and return
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}

test "differential: bitwise operations edge cases" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Test AND, OR, XOR, NOT with edge values
    const bytecode = [_]u8{
        // AND: MAX_U256 & 0 = 0
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x60, 0x00, // PUSH1 0
        0x16,       // AND (result: 0)
        
        // OR: 0 | MAX_U256 = MAX_U256
        0x60, 0x00, // PUSH1 0
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x17,       // OR (result: MAX_U256)
        
        // XOR: MAX_U256 ^ MAX_U256 = 0
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 MAX_U256
        0x18,       // XOR (result: 0)
        
        // NOT: ~0 = MAX_U256
        0x60, 0x00, // PUSH1 0
        0x19,       // NOT (result: MAX_U256)
        
        // XOR the last two to get 0
        0x18,       // XOR
        
        // Add with first result: 0 + 0 = 0
        0x01,       // ADD
        
        // Store and return
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}

test "differential: shift operations edge cases" {
    const allocator = testing.allocator;
    
    var testor = try DifferentialTestor.init(allocator);
    defer testor.deinit();
    
    // Test SHL, SHR, SAR with edge cases
    const bytecode = [_]u8{
        // SHL: 1 << 255 = 0x8000...0000
        0x60, 0x01, // PUSH1 1
        0x60, 0xff, // PUSH1 255
        0x1b,       // SHL
        
        // SHR: result >> 255 = 1
        0x60, 0xff, // PUSH1 255
        0x1c,       // SHR (result: 1)
        
        // SHL: 1 << 256 = 0 (shift >= 256 = 0)
        0x60, 0x01, // PUSH1 1
        0x61, 0x01, 0x00, // PUSH2 256
        0x1b,       // SHL (result: 0)
        
        // SAR: -1 >> N = -1 (arithmetic shift)
        0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // PUSH32 -1
        0x60, 0x80, // PUSH1 128
        0x1d,       // SAR (result: -1)
        
        // Add first two results: 1 + 0 = 1
        0x01,       // ADD
        0x01,       // ADD
        
        // XOR with -1 to get NOT(1) = MAX_U256 - 1
        0x18,       // XOR
        
        // Store and return
        0x60, 0x00, // PUSH1 0
        0x52,       // MSTORE
        0x60, 0x20, // PUSH1 32
        0x60, 0x00, // PUSH1 0
        0xf3,       // RETURN
    };
    
    try testor.test_bytecode(&bytecode);
}
