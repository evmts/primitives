const std = @import("std");

pub fn build_bytecode(allocator: std.mem.Allocator, opcode: u8) ![]u8 {
    var buf = std.ArrayList(u8){};
    errdefer buf.deinit(allocator);

    // Helper functions as a struct namespace
    const helpers = struct {
        inline fn push_bytes(alloc: std.mem.Allocator, b: *std.ArrayList(u8), data: []const u8) !void {
            if (data.len == 0) {
                try b.append(alloc, 0x5f); // PUSH0
                return;
            }
            if (data.len > 32) return error.InvalidPushLength;
            const op: u8 = 0x60 + @as(u8, @intCast(data.len - 1));
            try b.append(alloc, op);
            try b.appendSlice(alloc, data);
        }

        inline fn push_u8(alloc: std.mem.Allocator, b: *std.ArrayList(u8), v: u8) !void {
            if (v == 0) {
                try b.append(alloc, 0x5f); // PUSH0
            } else {
                try b.append(alloc, 0x60); // PUSH1
                try b.append(alloc, v);
            }
        }

        inline fn push_u16(alloc: std.mem.Allocator, b: *std.ArrayList(u8), v: u16) !void {
            if (v <= 0xff) {
                try push_u8(alloc, b, @intCast(v));
            } else {
                try b.append(alloc, 0x61); // PUSH2
                try b.append(alloc, @intCast((v >> 8) & 0xff));
                try b.append(alloc, @intCast(v & 0xff));
            }
        }

        inline fn push_u256(alloc: std.mem.Allocator, b: *std.ArrayList(u8), v: u256) !void {
            if (v == 0) return push_u8(alloc, b, 0);
            var tmp: [32]u8 = [_]u8{0} ** 32;
            std.mem.writeInt(u256, &tmp, v, .big);
            const first_non_zero = std.mem.indexOfNonePos(u8, &tmp, 0, &[_]u8{0}) orelse 32;
            const slice = tmp[first_non_zero..];
            try push_bytes(alloc, b, slice);
        }

        inline fn ret_top32(alloc: std.mem.Allocator, b: *std.ArrayList(u8)) !void {
            // MSTORE at offset 0 then return 32 bytes
            try push_u8(alloc, b, 0x00);
            try b.append(alloc, 0x52); // MSTORE
            try push_u8(alloc, b, 0x20);
            try push_u8(alloc, b, 0x00);
            try b.append(alloc, 0xf3); // RETURN
        }

        inline fn ret_const(alloc: std.mem.Allocator, b: *std.ArrayList(u8), v: u256) !void {
            try push_u256(alloc, b, v);
            try ret_top32(alloc, b);
        }

        inline fn discard_top_and_return_const(alloc: std.mem.Allocator, b: *std.ArrayList(u8), v: u256) !void {
            try b.append(alloc, 0x50); // POP
            try ret_const(alloc, b, v);
        }
    };

    // Build by category
    switch (opcode) {
        // 0x00 STOP
        0x00 => {
            try buf.append(allocator, 0x00);
            // No return; STOP exits successfully with empty output
        },

        // Arithmetic 0x01..0x0b
        0x01 => { // ADD
            try helpers.push_u8(allocator, &buf, 0x02);
            try helpers.push_u8(allocator, &buf, 0x03);
            try buf.append(allocator, 0x01);
            try helpers.ret_top32(allocator, &buf);
        },
        0x02 => { // MUL
            try helpers.push_u8(allocator, &buf, 0x02);
            try helpers.push_u8(allocator, &buf, 0x05);
            try buf.append(allocator, 0x02);
            try helpers.ret_top32(allocator, &buf);
        },
        0x03 => { // SUB
            try helpers.push_u8(allocator, &buf, 0x0a);
            try helpers.push_u8(allocator, &buf, 0x03);
            try buf.append(allocator, 0x03);
            try helpers.ret_top32(allocator, &buf);
        },
        0x04 => { // DIV
            try helpers.push_u8(allocator, &buf, 0x14);
            try helpers.push_u8(allocator, &buf, 0x04);
            try buf.append(allocator, 0x04);
            try helpers.ret_top32(allocator, &buf);
        },
        0x05 => { // SDIV (-10 / 3)
            // push -10 as 32 bytes
            var minus10: [32]u8 = [_]u8{0xff} ** 32;
            minus10[31] = 0xf6; // two's complement -10
            try helpers.push_bytes(allocator, &buf, &minus10);
            try helpers.push_u8(allocator, &buf, 0x03);
            try buf.append(allocator, 0x05);
            try helpers.ret_top32(allocator, &buf);
        },
        0x06 => { // MOD
            try helpers.push_u8(allocator, &buf, 0x11);
            try helpers.push_u8(allocator, &buf, 0x05);
            try buf.append(allocator, 0x06);
            try helpers.ret_top32(allocator, &buf);
        },
        0x07 => { // SMOD
            var minus10b: [32]u8 = [_]u8{0xff} ** 32;
            minus10b[31] = 0xf6;
            try helpers.push_bytes(allocator, &buf, &minus10b);
            try helpers.push_u8(allocator, &buf, 0x03);
            try buf.append(allocator, 0x07);
            try helpers.ret_top32(allocator, &buf);
        },
        0x08 => { // ADDMOD
            try helpers.push_u8(allocator, &buf, 0x06);
            try helpers.push_u8(allocator, &buf, 0x0a);
            try helpers.push_u8(allocator, &buf, 0x05);
            try buf.append(allocator, 0x08);
            try helpers.ret_top32(allocator, &buf);
        },
        0x09 => { // MULMOD
            try helpers.push_u8(allocator, &buf, 0x07);
            try helpers.push_u8(allocator, &buf, 0x04);
            try helpers.push_u8(allocator, &buf, 0x05);
            try buf.append(allocator, 0x09);
            try helpers.ret_top32(allocator, &buf);
        },
        0x0a => { // EXP 2^3
            try helpers.push_u8(allocator, &buf, 0x02);
            try helpers.push_u8(allocator, &buf, 0x03);
            try buf.append(allocator, 0x0a);
            try helpers.ret_top32(allocator, &buf);
        },
        0x0b => { // SIGNEXTEND
            // Extend 1 byte negative (-1)
            try helpers.push_u8(allocator, &buf, 0x01);
            var neg1: [32]u8 = [_]u8{0xff} ** 32;
            try helpers.push_bytes(allocator, &buf, &neg1);
            try buf.append(allocator, 0x0b);
            try helpers.ret_top32(allocator, &buf);
        },

        // Comparisons and bitwise 0x10..0x1d
        0x10 => { // LT
            try helpers.push_u8(&buf, 0x03);
            try helpers.push_u8(&buf, 0x04);
            try buf.append(allocator, 0x10);
            try helpers.ret_top32(&buf);
        },
        0x11 => { // GT
            try helpers.push_u8(&buf, 0x05);
            try helpers.push_u8(&buf, 0x04);
            try buf.append(allocator, 0x11);
            try helpers.ret_top32(&buf);
        },
        0x12 => { // SLT
            var neg2: [32]u8 = [_]u8{0xff} ** 32;
            neg2[31] = 0xfe; // -2
            try helpers.push_bytes(&buf, &neg2);
            try helpers.push_u8(&buf, 0x01);
            try buf.append(allocator, 0x12);
            try helpers.ret_top32(&buf);
        },
        0x13 => { // SGT
            var neg2b: [32]u8 = [_]u8{0xff} ** 32;
            neg2b[31] = 0xfe; // -2
            try helpers.push_u8(&buf, 0x01);
            try helpers.push_bytes(&buf, &neg2b);
            try buf.append(allocator, 0x13);
            try helpers.ret_top32(&buf);
        },
        0x14 => { // EQ
            try helpers.push_u8(&buf, 0x2a);
            try helpers.push_u8(&buf, 0x2a);
            try buf.append(allocator, 0x14);
            try helpers.ret_top32(&buf);
        },
        0x15 => { // ISZERO
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x15);
            try helpers.ret_top32(&buf);
        },
        0x16 => { // AND
            try helpers.push_u8(&buf, 0xf0);
            try helpers.push_u8(&buf, 0x0f);
            try buf.append(allocator, 0x16);
            try helpers.ret_top32(&buf);
        },
        0x17 => { // OR
            try helpers.push_u8(&buf, 0xf0);
            try helpers.push_u8(&buf, 0x0f);
            try buf.append(allocator, 0x17);
            try helpers.ret_top32(&buf);
        },
        0x18 => { // XOR
            try helpers.push_u8(&buf, 0xf0);
            try helpers.push_u8(&buf, 0x0f);
            try buf.append(allocator, 0x18);
            try helpers.ret_top32(&buf);
        },
        0x19 => { // NOT
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x19);
            try helpers.ret_top32(&buf);
        },
        0x1a => { // BYTE
            try helpers.push_u8(&buf, 0x1f); // index 31
            try helpers.push_u8(&buf, 0xaa);
            try buf.append(allocator, 0x1a);
            try helpers.ret_top32(&buf);
        },
        0x1b => { // SHL
            try helpers.push_u8(&buf, 0x01);
            try helpers.push_u8(&buf, 0x01);
            try buf.append(allocator, 0x1b);
            try helpers.ret_top32(&buf);
        },
        0x1c => { // SHR
            try helpers.push_u8(&buf, 0x01);
            try helpers.push_u8(&buf, 0x02);
            try buf.append(allocator, 0x1c);
            try helpers.ret_top32(&buf);
        },
        0x1d => { // SAR
            try helpers.push_u8(&buf, 0x01);
            var neg4: [32]u8 = [_]u8{0xff} ** 32;
            neg4[31] = 0xfc; // -4
            try helpers.push_bytes(&buf, &neg4);
            try buf.append(allocator, 0x1d);
            try helpers.ret_top32(&buf);
        },

        // Crypto
        0x20 => { // KECCAK256
            // Store 0x01 at memory[0], then KECCAK256(0,1)
            try helpers.push_u8(&buf, 0x01);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x53); // MSTORE8
            try helpers.push_u8(&buf, 0x01); // len
            try helpers.push_u8(&buf, 0x00); // offset
            try buf.append(allocator, 0x20); // KECCAK256
            try helpers.ret_top32(&buf);
        },

        // Environmental 0x30..0x3f
        0x30, 0x32, 0x33, 0x34, 0x36, 0x38, 0x3a, 0x3d => {
            // Zero-input getters: ADDRESS, ORIGIN, CALLER, CALLVALUE, CALLDATASIZE, CODESIZE, GASPRICE, RETURNDATASIZE
            try buf.append(allocator, opcode);
            try helpers.ret_top32(&buf);
        },
        0x31 => { // BALANCE(0)
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x31);
            try helpers.ret_top32(&buf);
        },
        0x35 => { // CALLDATALOAD(0) -> 0
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x35);
            try helpers.ret_top32(&buf);
        },
        0x37 => { // CALLDATACOPY(0,0,0) then return const
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x37);
            try helpers.ret_const(&buf, 0x2a);
        },
        0x39 => { // CODECOPY(0,0,0)
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x39);
            try helpers.ret_const(&buf, 0x2a);
        },
        0x3b, 0x3f => { // EXTCODESIZE/EXTCODEHASH(0)
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, opcode);
            try helpers.ret_top32(&buf);
        },
        0x3c => { // EXTCODECOPY(0,0,0,0)
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u16(&buf, 0x0000);
            try buf.append(allocator, 0x3c);
            try helpers.ret_const(&buf, 0x2a);
        },
        0x3e => { // RETURNDATACOPY(0,0,0)
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x3e);
            try helpers.ret_const(&buf, 0x2a);
        },

        // Block info 0x40..0x4a
        0x40, 0x49 => { // BLOCKHASH(0), BLOBHASH(0)
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, opcode);
            try helpers.ret_top32(&buf);
        },
        0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x4a => {
            // COINBASE, TIMESTAMP, NUMBER, DIFFICULTY/PREVRANDAO, GASLIMIT, CHAINID, SELFBALANCE, BASEFEE, BLOBBASEFEE
            try buf.append(allocator, opcode);
            try helpers.ret_top32(&buf);
        },

        // Stack/Memory/Storage/Flow 0x50..0x5e
        0x50 => { // POP
            try helpers.push_u8(&buf, 0x2a);
            try buf.append(allocator, 0x50);
            try helpers.ret_const(&buf, 0x01);
        },
        0x51 => { // MLOAD
            try helpers.push_u8(&buf, 0x2a);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x52); // MSTORE
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x51);
            try helpers.ret_top32(&buf);
        },
        0x52 => { // MSTORE then load to confirm
            try helpers.push_u8(&buf, 0x2b);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x52);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x51);
            try helpers.ret_top32(&buf);
        },
        0x53 => { // MSTORE8
            try helpers.push_u8(&buf, 0xab);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x53);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x51);
            try helpers.ret_top32(&buf);
        },
        0x54 => { // SLOAD(0) after SSTORE(0,1)
            try helpers.push_u8(&buf, 0x01);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x55); // SSTORE
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x54); // SLOAD
            try helpers.ret_top32(&buf);
        },
        0x55 => { // SSTORE(0,1) then SLOAD and return
            try helpers.push_u8(&buf, 0x01);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x55);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x54);
            try helpers.ret_top32(&buf);
        },
        0x56 => { // JUMP forward to label
            const dest: u16 = @intCast(buf.items.len + 3);
            try helpers.push_u16(&buf, dest);
            try buf.append(allocator, 0x56); // JUMP
            try buf.append(allocator, 0x5b); // JUMPDEST
            try helpers.ret_const(&buf, 0x01);
        },
        0x57 => { // JUMPI forward (always)
            const dest2: u16 = @intCast(buf.items.len + 4);
            try helpers.push_u16(&buf, dest2);
            try helpers.push_u8(&buf, 0x01); // condition true
            try buf.append(allocator, 0x57); // JUMPI
            try buf.append(allocator, 0x5b); // JUMPDEST
            try helpers.ret_const(&buf, 0x01);
        },
        0x58 => { // PC (discard)
            try buf.append(allocator, 0x58);
            try helpers.discard_top_and_return_const(&buf, 0x2a);
        },
        0x59 => { // MSIZE
            try buf.append(allocator, 0x59);
            try helpers.discard_top_and_return_const(&buf, 0x2a);
        },
        0x5a => { // GAS
            try buf.append(allocator, 0x5a);
            try helpers.discard_top_and_return_const(&buf, 0x2a);
        },
        0x5b => { // JUMPDEST (no-op)
            try buf.append(allocator, 0x5b);
            try helpers.ret_const(&buf, 0x2a);
        },
        0x5c => { // TLOAD(0) after TSTORE(0,1)
            try helpers.push_u8(&buf, 0x01);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x5d); // TSTORE
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x5c); // TLOAD
            try helpers.ret_top32(&buf);
        },
        0x5d => { // TSTORE(0,1)
            try helpers.push_u8(&buf, 0x01);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x5d);
            try helpers.ret_const(&buf, 0x01);
        },
        0x5e => { // MCOPY(0,0,0)
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x5e);
            try helpers.ret_const(&buf, 0x2a);
        },
        0x5f => { // PUSH0
            try buf.append(allocator, 0x5f);
            try helpers.ret_top32(&buf);
        },

        // PUSH1..PUSH32
        0x60...0x7f => {
            const n: u8 = opcode - 0x60 + 1;
            var data = try allocator.alloc(u8, n);
            defer allocator.free(data);
            // pattern 0x01,0x02,...
            var i: usize = 0;
            while (i < n) : (i += 1) data[i] = @intCast(i + 1);
            try helpers.push_bytes(&buf, data);
            try helpers.ret_top32(&buf);
        },

        // DUP1..DUP16
        0x80...0x8f => {
            const n: u8 = opcode - 0x80 + 1;
            var i: u8 = 1;
            while (i <= n) : (i += 1) {
                try helpers.push_u8(&buf, i);
            }
            try buf.append(allocator, opcode);
            try helpers.ret_top32(&buf);
        },

        // SWAP1..SWAP16
        0x90...0x9f => {
            const n: u8 = opcode - 0x90 + 1;
            // push n+1 values: 0..n so top is n
            var i: u8 = 0;
            while (i <= n) : (i += 1) {
                try helpers.push_u8(&buf, i);
            }
            try buf.append(allocator, opcode);
            try helpers.ret_top32(&buf);
        },

        // LOG0..LOG4
        0xa0...0xa4 => {
            const topics: u8 = opcode - 0xa0;
            // offset, size
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            var t: u8 = 0;
            while (t < topics) : (t += 1) {
                try helpers.push_u8(&buf, 0x00);
            }
            try buf.append(allocator, opcode);
            try helpers.ret_const(&buf, 0x01);
        },

        // 0xa5..0xef: undefined/reserved opcodes -> execute and let it trap
        0xa5...0xef => {
            try buf.append(allocator, opcode);
            // No return, expect invalid instruction
        },

        // System 0xf0..0xff
        0xf0 => { // CREATE (value, offset, size)
            try helpers.push_u8(&buf, 0x00); // value
            try helpers.push_u8(&buf, 0x00); // offset
            try helpers.push_u8(&buf, 0x00); // size
            try buf.append(allocator, 0xf0);
            try helpers.discard_top_and_return_const(&buf, 0x01);
        },
        0xf1 => { // CALL (gas,to,value,in_off,in_sz,out_off,out_sz)
            try helpers.push_u16(&buf, 20000); // gas
            try helpers.push_u8(&buf, 0x00); // to
            try helpers.push_u8(&buf, 0x00); // value
            try helpers.push_u8(&buf, 0x00); // in_off
            try helpers.push_u8(&buf, 0x00); // in_sz
            try helpers.push_u8(&buf, 0x00); // out_off
            try helpers.push_u8(&buf, 0x00); // out_sz
            try buf.append(allocator, 0xf1);
            try helpers.discard_top_and_return_const(&buf, 0x01);
        },
        0xf2 => { // CALLCODE
            try helpers.push_u16(&buf, 20000);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0xf2);
            try helpers.discard_top_and_return_const(&buf, 0x01);
        },
        0xf3 => { // RETURN immediate constant 0x2a
            try helpers.push_u8(&buf, 0x2a);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0x52); // MSTORE
            try helpers.push_u8(&buf, 0x20);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0xf3); // RETURN
        },
        0xf4 => { // DELEGATECALL (gas,to,in_off,in_sz,out_off,out_sz)
            try helpers.push_u16(&buf, 20000);
            try helpers.push_u8(&buf, 0x00); // to
            try helpers.push_u8(&buf, 0x00); // in_off
            try helpers.push_u8(&buf, 0x00); // in_sz
            try helpers.push_u8(&buf, 0x00); // out_off
            try helpers.push_u8(&buf, 0x00); // out_sz
            try buf.append(allocator, 0xf4);
            try helpers.discard_top_and_return_const(&buf, 0x01);
        },
        0xf5 => { // CREATE2 (value, offset, size, salt)
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0xf5);
            try helpers.discard_top_and_return_const(&buf, 0x01);
        },
        0xf6 => { // AUTH(authority,commitment,sig_v,sig_r,sig_s)
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x1b); // v=27 minimal valid range
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0xf6);
            try helpers.discard_top_and_return_const(&buf, 0x00);
        },
        0xf7 => { // AUTHCALL(gas,to,value,in_off,in_sz,out_off,out_sz,auth)
            try helpers.push_u16(&buf, 20000);
            try helpers.push_u8(&buf, 0x00); // to
            try helpers.push_u8(&buf, 0x00); // value
            try helpers.push_u8(&buf, 0x00); // in_off
            try helpers.push_u8(&buf, 0x00); // in_sz
            try helpers.push_u8(&buf, 0x00); // out_off
            try helpers.push_u8(&buf, 0x00); // out_sz
            try helpers.push_u8(&buf, 0x00); // auth flag false
            try buf.append(allocator, 0xf7);
            try helpers.discard_top_and_return_const(&buf, 0x00);
        },
        0xf8, 0xf9 => { // undefined
            try buf.append(allocator, opcode);
        },
        0xfa => { // STATICCALL(gas,to,in_off,in_sz,out_off,out_sz)
            try helpers.push_u16(&buf, 20000);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0xfa);
            try helpers.discard_top_and_return_const(&buf, 0x01);
        },
        0xfb, 0xfc => { // undefined
            try buf.append(allocator, opcode);
        },
        0xfd => { // REVERT(0,0)
            try helpers.push_u8(&buf, 0x00);
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0xfd);
        },
        0xfe => { // INVALID
            try buf.append(allocator, 0xfe);
        },
        0xff => { // SELFDESTRUCT(0x00)
            try helpers.push_u8(&buf, 0x00);
            try buf.append(allocator, 0xff);
        },

        else => {
            // Fallback: emit opcode and expect invalid
            try buf.append(allocator, opcode);
        },
    }

    return buf.toOwnedSlice(allocator);
}