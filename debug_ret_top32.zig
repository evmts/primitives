const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    
    var buf = std.ArrayList(u8).init(allocator);
    defer buf.deinit();
    
    const helpers = struct {
        inline fn push_u8(alloc: std.mem.Allocator, b: *std.ArrayList(u8), v: u8) !void {
            try b.append(alloc, 0x60); // PUSH1
            try b.append(alloc, v);
        }
        inline fn ret_top32(alloc: std.mem.Allocator, b: *std.ArrayList(u8)) !void {
            // MSTORE at offset 0 then return 32 bytes
            try push_u8(alloc, b, 0x00); // offset for MSTORE
            try b.append(alloc, 0x52); // MSTORE
            try push_u8(alloc, b, 0x00); // offset for RETURN (will be second from top)
            try push_u8(alloc, b, 0x20); // size for RETURN (will be on top)  
            try b.append(alloc, 0xf3); // RETURN
        }
    };
    
    // Test ret_top32 function
    try helpers.push_u8(allocator, &buf, 0x03); // value to shift
    try helpers.push_u8(allocator, &buf, 0x02); // shift amount
    try buf.append(allocator, 0x1b); // SHL
    try helpers.ret_top32(allocator, &buf);
    
    std.debug.print("Generated bytecode:\n", .{});
    std.debug.print("Length: {}\n", .{buf.items.len});
    std.debug.print("Bytes: ", .{});
    for (buf.items) |b| {
        std.debug.print("{x:0>2} ", .{b});
    }
    std.debug.print("\n", .{});
}